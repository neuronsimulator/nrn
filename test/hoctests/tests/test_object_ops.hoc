// Test object arithmetic and equality operations

// Test utility function
proc assert() {
    if ($1 == 0) {
        execerror("assert failed", "")
    }
}

print "Testing object arithmetic and equality operations..."

// Define a test class with magic methods
begintemplate MathClass
public value, __add__, __sub__, __mul__, __div__, __pow__, __eq__

proc init() {
    value = $1
}

func __add__() {
    return value + $o1.value
}

func __sub__() {
    return value - $o1.value
}

func __mul__() {
    return value * $o1.value
}

func __div__() {
    return value / $o1.value
}

func __pow__() {
    return value ^ $o1.value
}

func __eq__() {
    return value == $o1.value
}
endtemplate MathClass

// Define a class with both __eq__ and __ne__ methods
begintemplate CompareClass
public value, __eq__, __ne__

proc init() {
    value = $1
}

func __eq__() {
    print "__eq__ called for CompareClass"
    return value == $o1.value
}

func __ne__() {
    print "__ne__ called for CompareClass"
    return value != $o1.value
}
endtemplate CompareClass

// Test arithmetic operations
objref a, b, c
a = new MathClass(6)
b = new MathClass(3)
c = new MathClass(6)

// Test arithmetic
assert((a + b) == 9)     // 6 + 3 = 9
assert((a - b) == 3)     // 6 - 3 = 3
assert((a * b) == 18)    // 6 * 3 = 18
assert((a / b) == 2)     // 6 / 3 = 2
assert((a ^ b) == 216)   // 6^3 = 216

// Test equality with custom __eq__
assert(a == a)           // same object
assert(a == c)           // same value (6 == 6)
assert(!(a != c))        // test != using __eq__ negation
assert(!(a == b))        // different values (6 != 3)
assert(a != b)           // test != using __eq__ negation

// Test class with explicit __ne__ method
objref d, e, f
d = new CompareClass(10)
e = new CompareClass(10)
f = new CompareClass(20)

print "Testing __ne__ method explicitly:"
assert(d == e)           // should call __eq__ method
assert(!(d != e))        // should call __ne__ method
assert(d != f)           // should call __ne__ method
assert(!(d == f))        // should call __eq__ method

// Test objects without magic methods (fallback to pointer equality)
objref v1, v2, v3
v1 = new Vector(5)
v2 = new Vector(5)
v3 = v1

assert(v1 == v1)         // same object
assert(!(v1 == v2))      // different objects, same contents
assert(!(v1 != v1))
assert(v1 == v3)         // same reference

// Test null object handling
objref nullobj
assert(!(v1 == nullobj)) // object vs null
assert(nullobj == nullobj)
assert(v1 != nullobj)

// ===== MIXED-TYPE ARITHMETIC TESTS (Object + Number) =====
print "Testing mixed-type arithmetic operations (returning objects)..."

// Define a class that supports mixed-type operations returning objects
begintemplate MixedMathClass
public value, __add__, __radd__, __sub__, __rsub__, __mul__, __rmul__, __div__, __rdiv__, __pow__, __rpow__

proc init() {
    value = $1
}

// Addition operations
obfunc __add__() {
    if (numarg() == 1) {
        // obj + number
        return new MixedMathClass(value + $1)
    } else {
        // obj + obj (shouldn't happen in mixed-type, but for completeness)
        return new MixedMathClass(value + $o1.value)
    }
}

obfunc __radd__() {
    // number + obj
    return new MixedMathClass($1 + value)
}

// Subtraction operations  
obfunc __sub__() {
    if (numarg() == 1) {
        // obj - number
        return new MixedMathClass(value - $1)
    } else {
        // obj - obj
        return new MixedMathClass(value - $o1.value)
    }
}

obfunc __rsub__() {
    // number - obj
    return new MixedMathClass($1 - value)
}

// Multiplication operations
obfunc __mul__() {
    if (numarg() == 1) {
        // obj * number
        return new MixedMathClass(value * $1)
    } else {
        // obj * obj
        return new MixedMathClass(value * $o1.value)
    }
}

obfunc __rmul__() {
    // number * obj
    return new MixedMathClass($1 * value)
}

// Division operations
obfunc __div__() {
    if (numarg() == 1) {
        // obj / number
        return new MixedMathClass(value / $1)
    } else {
        // obj / obj
        return new MixedMathClass(value / $o1.value)
    }
}

obfunc __rdiv__() {
    // number / obj
    return new MixedMathClass($1 / value)
}

// Power operations
obfunc __pow__() {
    if (numarg() == 1) {
        // obj ^ number
        return new MixedMathClass(value ^ $1)
    } else {
        // obj ^ obj
        return new MixedMathClass(value ^ $o1.value)
    }
}

obfunc __rpow__() {
    // number ^ obj
    return new MixedMathClass($1 ^ value)
}

endtemplate MixedMathClass

// Create test objects for mixed-type operations
objref mix1, result_obj
mix1 = new MixedMathClass(10)

print "Testing object + number operations (both orders):"

// Test addition: obj + num and num + obj
result_obj = mix1 + 5
assert(result_obj.value == 15)  // 10 + 5
print "  obj + 5 = ", result_obj.value

result_obj = 7 + mix1
assert(result_obj.value == 17)  // 7 + 10
print "  7 + obj = ", result_obj.value

// Test subtraction: obj - num and num - obj
result_obj = mix1 - 3
assert(result_obj.value == 7)   // 10 - 3
print "  obj - 3 = ", result_obj.value

result_obj = 15 - mix1
assert(result_obj.value == 5)   // 15 - 10
print "  15 - obj = ", result_obj.value

// Test multiplication: obj * num and num * obj
result_obj = mix1 * 4
assert(result_obj.value == 40)  // 10 * 4
print "  obj * 4 = ", result_obj.value

result_obj = 6 * mix1
assert(result_obj.value == 60)  // 6 * 10
print "  6 * obj = ", result_obj.value

// Test division: obj / num and num / obj
result_obj = mix1 / 2
assert(result_obj.value == 5)   // 10 / 2
print "  obj / 2 = ", result_obj.value

result_obj = 50 / mix1
assert(result_obj.value == 5)   // 50 / 10
print "  50 / obj = ", result_obj.value

// Test power: obj ^ num and num ^ obj  
result_obj = mix1 ^ 2
assert(result_obj.value == 100) // 10 ^ 2
print "  obj ^ 2 = ", result_obj.value

// Create object with smaller value for reasonable power test
objref mix2
mix2 = new MixedMathClass(3)
result_obj = 2 ^ mix2
assert(result_obj.value == 8)   // 2 ^ 3
print "  2 ^ obj(3) = ", result_obj.value

print "All mixed-type arithmetic tests passed!"

print "All object operation tests passed!"

quit()
