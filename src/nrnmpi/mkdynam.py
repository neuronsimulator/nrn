#!/usr/bin/env python3

"""
Script for generating MPI headers.
"""

import re
import sys
from pathlib import Path


def extract_function_names(header_content: str) -> list[str]:
    """Extract nrnmpi function names from header file."""
    pattern = r"extern [a-z*]* (nrnmpi_[a-zA-Z0-9_]*)\(.*\);"
    return re.findall(pattern, header_content, re.MULTILINE)


def parse_function_signatures(header_content: str) -> list[tuple[str, str, str]]:
    """Parse function signatures and return (return_type, name, params)."""
    signatures = []

    # Match void functions
    void_pattern = r"extern (void) (nrnmpi_[a-zA-Z0-9_]*)(\(.*?\));"
    for match in re.finditer(void_pattern, header_content, re.MULTILINE):
        signatures.append(("void", match.group(2), match.group(3)))

    # Match non-void functions
    nonvoid_pattern = r"extern ([a-z*]+) (nrnmpi_[a-zA-Z0-9_]*)(\(.*?\));"
    for match in re.finditer(nonvoid_pattern, header_content, re.MULTILINE):
        if match.group(1) != "void":
            signatures.append((match.group(1), match.group(2), match.group(3)))

    return signatures


def clean_params(params: str) -> str:
    """Remove type information from parameters, keeping only parameter names."""
    # Remove const qualifiers and types
    cleaned = re.sub(r", const [a-zA-Z0-9_:*&]* ", ", ", params)
    cleaned = re.sub(r"\(const [a-zA-Z0-9_:*&]* ", "(", cleaned)
    cleaned = re.sub(r", [a-zA-Z0-9_:*&]* ", ", ", cleaned)
    cleaned = re.sub(r"\([a-zA-Z0-9_:*&]* ", "(", cleaned)
    cleaned = re.sub(r"const& ", "", cleaned)
    cleaned = re.sub(r"char\* ", "", cleaned)
    cleaned = re.sub(r"char\*\* ", "", cleaned)
    cleaned = re.sub(r"std::string& ", "", cleaned)
    return cleaned


def generate_wrappers(signatures: list[tuple[str, str, str]]) -> str:
    """Generate nrnmpi_dynam_wrappers.inc content."""
    lines = []

    for return_type, name, params in signatures:
        clean_call_params = clean_params(params)

        if return_type == "void":
            wrapper = f"{return_type} {name}{params} {{\n  (*p_{name}){clean_call_params};\n}}"
        else:
            wrapper = f"{return_type} {name}{params} {{\n  return (*p_{name}){clean_call_params};\n}}"

        lines.append(wrapper)

    return "\n".join(lines)


def generate_dynam_h(names: list[str]) -> str:
    """Generate nrnmpi_dynam.h content."""
    lines = [
        "#ifndef nrnmpi_dynam_h",
        "#define nrnmpi_dynam_h",
        "/* generated by mkdynam.py */",
        "",
        "#if NRNMPI_DYNAMICLOAD",
        "",
    ]

    for name in names:
        lines.append(f"#define {name} f_{name}")

    lines.extend(["", "#endif /* NRNMPI_DYNAMICLOAD */", "", "#endif", ""])

    return "\n".join(lines)


def generate_dynam_cinc(header_content: str, names: list[str]) -> str:
    """Generate nrnmpi_dynam_cinc content."""
    lines = []

    # Generate function pointer declarations
    pattern = r"extern ([a-z*]*) (nrnmpi_[a-zA-Z0-9_]*)(\(.*?\));"
    for match in re.finditer(pattern, header_content, re.MULTILINE):
        return_type, name, params = match.groups()
        lines.append(f"static {return_type} (*p_{name}){params};")

    lines.extend(
        [
            "",
            "static struct {",
            "\tconst char* name;",
            "\tvoid** ppf;",
            "} ftable[] = {",
        ]
    )

    for name in names:
        lines.append(f'\t"f_{name}", (void**)&p_{name},')

    lines.extend(["\t0,0", "};", ""])

    return "\n".join(lines)


def main():
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} OUTPUT_PATH", file=sys.stderr)
        sys.exit(1)

    output_path = Path(sys.argv[1])
    output_path.mkdir(parents=True, exist_ok=True)

    # Read header file
    header_file = Path("nrnmpidec.h")
    if not header_file.exists():
        print(f"Error: {header_file} not found", file=sys.stderr)
        sys.exit(1)

    header_content = header_file.read_text()

    # Extract function names
    names = extract_function_names(header_content)

    # Parse function signatures for wrappers
    signatures = parse_function_signatures(header_content)

    # Generate files
    wrappers = generate_wrappers(signatures)
    dynam_h = generate_dynam_h(names)
    dynam_cinc = generate_dynam_cinc(header_content, names)

    # Write output files
    (output_path / "nrnmpi_dynam_wrappers.inc").write_text(wrappers)
    (output_path / "nrnmpi_dynam.h").write_text(dynam_h)
    (output_path / "nrnmpi_dynam_cinc").write_text(dynam_cinc)

    print(f"Generated files in {output_path}/")


if __name__ == "__main__":
    main()
