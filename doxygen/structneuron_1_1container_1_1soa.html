<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NEURON: neuron::container::soa&lt; Storage, Tags &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NEURON
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structneuron_1_1container_1_1soa.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="structneuron_1_1container_1_1soa-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">neuron::container::soa&lt; Storage, Tags &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Utility for generating SOA data structures.  
 <a href="structneuron_1_1container_1_1soa.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="soa__container_8hpp_source.html">neuron/container/soa_container.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a803693e65c0bece85c5c1399c7894689"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a803693e65c0bece85c5c1399c7894689">frozen_token_type</a> = <a class="el" href="structneuron_1_1container_1_1state__token.html">state_token</a>&lt; Storage &gt;</td></tr>
<tr class="memdesc:a803693e65c0bece85c5c1399c7894689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type of <a class="el" href="structneuron_1_1container_1_1soa.html#a54b3da5eeb40d7038f4eac42fc53dd05" title="Create a token guaranteeing the container is in &quot;frozen&quot; state.">issue_frozen_token()</a>  <a href="structneuron_1_1container_1_1soa.html#a803693e65c0bece85c5c1399c7894689">More...</a><br /></td></tr>
<tr class="separator:a803693e65c0bece85c5c1399c7894689"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acbc4471c3453a1ff74e34d395524b331"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#acbc4471c3453a1ff74e34d395524b331">soa</a> ()</td></tr>
<tr class="memdesc:acbc4471c3453a1ff74e34d395524b331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct with default-constructed tag type instances.  <a href="structneuron_1_1container_1_1soa.html#acbc4471c3453a1ff74e34d395524b331">More...</a><br /></td></tr>
<tr class="separator:acbc4471c3453a1ff74e34d395524b331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a6493673231f25b2d612aa180ea305"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a87a6493673231f25b2d612aa180ea305">soa</a> (Tags... tag_instances)</td></tr>
<tr class="memdesc:a87a6493673231f25b2d612aa180ea305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct with specific tag instances.  <a href="structneuron_1_1container_1_1soa.html#a87a6493673231f25b2d612aa180ea305">More...</a><br /></td></tr>
<tr class="separator:a87a6493673231f25b2d612aa180ea305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bc8880ea57b2a84704d24f57e04d33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a21bc8880ea57b2a84704d24f57e04d33">soa</a> (<a class="el" href="structneuron_1_1container_1_1soa.html">soa</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a21bc8880ea57b2a84704d24f57e04d33"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structneuron_1_1container_1_1soa.html">soa</a> is not movable  <a href="structneuron_1_1container_1_1soa.html#a21bc8880ea57b2a84704d24f57e04d33">More...</a><br /></td></tr>
<tr class="separator:a21bc8880ea57b2a84704d24f57e04d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2321012aed74c4a98b7b177e21009ee7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a2321012aed74c4a98b7b177e21009ee7">soa</a> (<a class="el" href="structneuron_1_1container_1_1soa.html">soa</a> const &amp;)=delete</td></tr>
<tr class="memdesc:a2321012aed74c4a98b7b177e21009ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structneuron_1_1container_1_1soa.html">soa</a> is not copiable  <a href="structneuron_1_1container_1_1soa.html#a2321012aed74c4a98b7b177e21009ee7">More...</a><br /></td></tr>
<tr class="separator:a2321012aed74c4a98b7b177e21009ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a7fb9834f2ea5cf5920eb8043ccfe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structneuron_1_1container_1_1soa.html">soa</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a18a7fb9834f2ea5cf5920eb8043ccfe7">operator=</a> (<a class="el" href="structneuron_1_1container_1_1soa.html">soa</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a18a7fb9834f2ea5cf5920eb8043ccfe7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structneuron_1_1container_1_1soa.html">soa</a> is not move assignable  <a href="structneuron_1_1container_1_1soa.html#a18a7fb9834f2ea5cf5920eb8043ccfe7">More...</a><br /></td></tr>
<tr class="separator:a18a7fb9834f2ea5cf5920eb8043ccfe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6db3bae651f3ed8a62e944190b3641a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structneuron_1_1container_1_1soa.html">soa</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#ab6db3bae651f3ed8a62e944190b3641a">operator=</a> (<a class="el" href="structneuron_1_1container_1_1soa.html">soa</a> const &amp;)=delete</td></tr>
<tr class="memdesc:ab6db3bae651f3ed8a62e944190b3641a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structneuron_1_1container_1_1soa.html">soa</a> is not copy assignable  <a href="structneuron_1_1container_1_1soa.html#ab6db3bae651f3ed8a62e944190b3641a">More...</a><br /></td></tr>
<tr class="separator:ab6db3bae651f3ed8a62e944190b3641a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567b1b33e63684c03113e2358bcadb04"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a567b1b33e63684c03113e2358bcadb04">size</a> () const</td></tr>
<tr class="memdesc:a567b1b33e63684c03113e2358bcadb04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the container.  <a href="structneuron_1_1container_1_1soa.html#a567b1b33e63684c03113e2358bcadb04">More...</a><br /></td></tr>
<tr class="separator:a567b1b33e63684c03113e2358bcadb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67063379b06b305c5717832c255c7f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#ad67063379b06b305c5717832c255c7f7">empty</a> () const</td></tr>
<tr class="memdesc:ad67063379b06b305c5717832c255c7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the container is empty.  <a href="structneuron_1_1container_1_1soa.html#ad67063379b06b305c5717832c255c7f7">More...</a><br /></td></tr>
<tr class="separator:ad67063379b06b305c5717832c255c7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa693195c45fff0c38c735d915cc6ddb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#aa693195c45fff0c38c735d915cc6ddb7">shrink_to_fit</a> ()</td></tr>
<tr class="separator:aa693195c45fff0c38c735d915cc6ddb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b3da5eeb40d7038f4eac42fc53dd05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structneuron_1_1container_1_1soa.html#a803693e65c0bece85c5c1399c7894689">frozen_token_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a54b3da5eeb40d7038f4eac42fc53dd05">issue_frozen_token</a> ()</td></tr>
<tr class="memdesc:a54b3da5eeb40d7038f4eac42fc53dd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a token guaranteeing the container is in "frozen" state.  <a href="structneuron_1_1container_1_1soa.html#a54b3da5eeb40d7038f4eac42fc53dd05">More...</a><br /></td></tr>
<tr class="separator:a54b3da5eeb40d7038f4eac42fc53dd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52be9084ec23bdc9e736083f7ce5264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#ac52be9084ec23bdc9e736083f7ce5264">mark_as_sorted</a> (<a class="el" href="structneuron_1_1container_1_1soa.html#a803693e65c0bece85c5c1399c7894689">frozen_token_type</a> &amp;write_token)</td></tr>
<tr class="memdesc:ac52be9084ec23bdc9e736083f7ce5264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the container it is sorted.  <a href="structneuron_1_1container_1_1soa.html#ac52be9084ec23bdc9e736083f7ce5264">More...</a><br /></td></tr>
<tr class="separator:ac52be9084ec23bdc9e736083f7ce5264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908668b49668da296f5ee09974f223f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a908668b49668da296f5ee09974f223f8">mark_as_unsorted</a> ()</td></tr>
<tr class="memdesc:a908668b49668da296f5ee09974f223f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the container it is no longer sorted.  <a href="structneuron_1_1container_1_1soa.html#a908668b49668da296f5ee09974f223f8">More...</a><br /></td></tr>
<tr class="separator:a908668b49668da296f5ee09974f223f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072b58a08ca1b0d5db41e9216b9ec431"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a072b58a08ca1b0d5db41e9216b9ec431">set_unsorted_callback</a> (std::function&lt; void()&gt; unsorted_callback)</td></tr>
<tr class="memdesc:a072b58a08ca1b0d5db41e9216b9ec431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback that is invoked when the container becomes unsorted.  <a href="structneuron_1_1container_1_1soa.html#a072b58a08ca1b0d5db41e9216b9ec431">More...</a><br /></td></tr>
<tr class="separator:a072b58a08ca1b0d5db41e9216b9ec431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10aee5bc82e78fbfe2932ee36fce57f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a10aee5bc82e78fbfe2932ee36fce57f2">is_sorted</a> () const</td></tr>
<tr class="memdesc:a10aee5bc82e78fbfe2932ee36fce57f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if the underlying vectors are still "sorted".  <a href="structneuron_1_1container_1_1soa.html#a10aee5bc82e78fbfe2932ee36fce57f2">More...</a><br /></td></tr>
<tr class="separator:a10aee5bc82e78fbfe2932ee36fce57f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5aae504ab331f98fe7e16511bd5638d"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ad5aae504ab331f98fe7e16511bd5638d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structneuron_1_1container_1_1soa.html#a803693e65c0bece85c5c1399c7894689">frozen_token_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#ad5aae504ab331f98fe7e16511bd5638d">apply_reverse_permutation</a> (Arg &amp;&amp;permutation)</td></tr>
<tr class="memdesc:ad5aae504ab331f98fe7e16511bd5638d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permute the SoA-format data using an arbitrary range of integers.  <a href="structneuron_1_1container_1_1soa.html#ad5aae504ab331f98fe7e16511bd5638d">More...</a><br /></td></tr>
<tr class="separator:ad5aae504ab331f98fe7e16511bd5638d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955cd5e607f0877a85fc38174af11d17"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a955cd5e607f0877a85fc38174af11d17"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a955cd5e607f0877a85fc38174af11d17">apply_reverse_permutation</a> (Range permutation, <a class="el" href="structneuron_1_1container_1_1soa.html#a803693e65c0bece85c5c1399c7894689">frozen_token_type</a> &amp;sorted_token)</td></tr>
<tr class="memdesc:a955cd5e607f0877a85fc38174af11d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permute the SoA-format data using an arbitrary range of integers.  <a href="structneuron_1_1container_1_1soa.html#a955cd5e607f0877a85fc38174af11d17">More...</a><br /></td></tr>
<tr class="separator:a955cd5e607f0877a85fc38174af11d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc0940857c918c76dc67ef8eb8da8fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structneuron_1_1container_1_1non__owning__identifier.html">non_owning_identifier</a>&lt; Storage &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a8cc0940857c918c76dc67ef8eb8da8fe">at</a> (std::size_t offset) const</td></tr>
<tr class="memdesc:a8cc0940857c918c76dc67ef8eb8da8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a non-owning identifier to the offset-th entry.  <a href="structneuron_1_1container_1_1soa.html#a8cc0940857c918c76dc67ef8eb8da8fe">More...</a><br /></td></tr>
<tr class="separator:a8cc0940857c918c76dc67ef8eb8da8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1ad473fc9cca00cd3378c12bc99b91"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:a8c1ad473fc9cca00cd3378c12bc99b91"><td class="memTemplItemLeft" align="right" valign="top">constexpr Tag const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a8c1ad473fc9cca00cd3378c12bc99b91">get_tag</a> () const</td></tr>
<tr class="memdesc:a8c1ad473fc9cca00cd3378c12bc99b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the instance of the given tag type.  <a href="structneuron_1_1container_1_1soa.html#a8c1ad473fc9cca00cd3378c12bc99b91">More...</a><br /></td></tr>
<tr class="separator:a8c1ad473fc9cca00cd3378c12bc99b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52fd7c9f91056d8249cc17d514ef0a3b"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:a52fd7c9f91056d8249cc17d514ef0a3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="nrnoc_2cabvars_8h.html#acd579dfd50a9ea905ca697ed8707bf3b">Tag::type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a52fd7c9f91056d8249cc17d514ef0a3b">get</a> (std::size_t offset)</td></tr>
<tr class="memdesc:a52fd7c9f91056d8249cc17d514ef0a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the offset-th element of the column named by Tag.  <a href="structneuron_1_1container_1_1soa.html#a52fd7c9f91056d8249cc17d514ef0a3b">More...</a><br /></td></tr>
<tr class="separator:a52fd7c9f91056d8249cc17d514ef0a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad601f80f6b0531a3877a2fd9c8230a2b"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:ad601f80f6b0531a3877a2fd9c8230a2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="nrnoc_2cabvars_8h.html#acd579dfd50a9ea905ca697ed8707bf3b">Tag::type</a> const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#ad601f80f6b0531a3877a2fd9c8230a2b">get</a> (std::size_t offset) const</td></tr>
<tr class="memdesc:ad601f80f6b0531a3877a2fd9c8230a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the offset-th element of the column named by Tag.  <a href="structneuron_1_1container_1_1soa.html#ad601f80f6b0531a3877a2fd9c8230a2b">More...</a><br /></td></tr>
<tr class="separator:ad601f80f6b0531a3877a2fd9c8230a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0490ded7230ec2a83ec1e6fc8f6644"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:ada0490ded7230ec2a83ec1e6fc8f6644"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structneuron_1_1container_1_1data__handle.html">data_handle</a>&lt; typename <a class="el" href="nrnoc_2cabvars_8h.html#acd579dfd50a9ea905ca697ed8707bf3b">Tag::type</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#ada0490ded7230ec2a83ec1e6fc8f6644">get_handle</a> (<a class="el" href="structneuron_1_1container_1_1non__owning__identifier__without__container.html">non_owning_identifier_without_container</a> <a class="el" href="nrnoc_2md1redef_8h.html#a6dc5438d7da45fe939a6b00cb23365a3">id</a>, int array_index=0) const</td></tr>
<tr class="memdesc:ada0490ded7230ec2a83ec1e6fc8f6644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to the given element of the column named by Tag.  <a href="structneuron_1_1container_1_1soa.html#ada0490ded7230ec2a83ec1e6fc8f6644">More...</a><br /></td></tr>
<tr class="separator:ada0490ded7230ec2a83ec1e6fc8f6644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8daed8465bd3f74ab7fd9ba1d86c07"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:afa8daed8465bd3f74ab7fd9ba1d86c07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structneuron_1_1container_1_1data__handle.html">data_handle</a>&lt; typename <a class="el" href="nrnoc_2cabvars_8h.html#acd579dfd50a9ea905ca697ed8707bf3b">Tag::type</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#afa8daed8465bd3f74ab7fd9ba1d86c07">get_field_instance_handle</a> (<a class="el" href="structneuron_1_1container_1_1non__owning__identifier__without__container.html">non_owning_identifier_without_container</a> <a class="el" href="nrnoc_2md1redef_8h.html#a6dc5438d7da45fe939a6b00cb23365a3">id</a>, int <a class="el" href="structneuron_1_1container_1_1field__index.html">field_index</a>, int array_index=0) const</td></tr>
<tr class="memdesc:afa8daed8465bd3f74ab7fd9ba1d86c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to the given element of the field_index-th column named by Tag.  <a href="structneuron_1_1container_1_1soa.html#afa8daed8465bd3f74ab7fd9ba1d86c07">More...</a><br /></td></tr>
<tr class="separator:afa8daed8465bd3f74ab7fd9ba1d86c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471881081c25cf7aea38a4cdc3c8c8d5"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:a471881081c25cf7aea38a4cdc3c8c8d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="nrnoc_2cabvars_8h.html#acd579dfd50a9ea905ca697ed8707bf3b">Tag::type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a471881081c25cf7aea38a4cdc3c8c8d5">get_field_instance</a> (std::size_t offset, int <a class="el" href="structneuron_1_1container_1_1field__index.html">field_index</a>, int array_index=0)</td></tr>
<tr class="memdesc:a471881081c25cf7aea38a4cdc3c8c8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the offset-th element of the field_index-th instance of the column named by Tag.  <a href="structneuron_1_1container_1_1soa.html#a471881081c25cf7aea38a4cdc3c8c8d5">More...</a><br /></td></tr>
<tr class="separator:a471881081c25cf7aea38a4cdc3c8c8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7aca35ebbb8003945b0f2ab59eb777b"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:ad7aca35ebbb8003945b0f2ab59eb777b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="nrnoc_2cabvars_8h.html#acd579dfd50a9ea905ca697ed8707bf3b">Tag::type</a> const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#ad7aca35ebbb8003945b0f2ab59eb777b">get_field_instance</a> (std::size_t offset, int <a class="el" href="structneuron_1_1container_1_1field__index.html">field_index</a>, int array_index=0) const</td></tr>
<tr class="memdesc:ad7aca35ebbb8003945b0f2ab59eb777b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the offset-th element of the field_index-th instance of the column named by Tag.  <a href="structneuron_1_1container_1_1soa.html#ad7aca35ebbb8003945b0f2ab59eb777b">More...</a><br /></td></tr>
<tr class="separator:ad7aca35ebbb8003945b0f2ab59eb777b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e745d863fd672f1380f981a0f213b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structneuron_1_1container_1_1non__owning__identifier__without__container.html">non_owning_identifier_without_container</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#aa3e745d863fd672f1380f981a0f213b0">get_identifier</a> (std::size_t offset) const</td></tr>
<tr class="memdesc:aa3e745d863fd672f1380f981a0f213b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the offset-th identifier.  <a href="structneuron_1_1container_1_1soa.html#aa3e745d863fd672f1380f981a0f213b0">More...</a><br /></td></tr>
<tr class="separator:aa3e745d863fd672f1380f981a0f213b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c391ab9bb358f5ca8a72512fcdbcf64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structneuron_1_1container_1_1generic__data__handle.html">neuron::container::generic_data_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a5c391ab9bb358f5ca8a72512fcdbcf64">find_data_handle</a> (<a class="el" href="structneuron_1_1container_1_1generic__data__handle.html">neuron::container::generic_data_handle</a> input_handle) const</td></tr>
<tr class="memdesc:a5c391ab9bb358f5ca8a72512fcdbcf64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a permutation-stable handle if ptr is inside us.  <a href="structneuron_1_1container_1_1soa.html#a5c391ab9bb358f5ca8a72512fcdbcf64">More...</a><br /></td></tr>
<tr class="separator:a5c391ab9bb358f5ca8a72512fcdbcf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d6731fd32b1a4ab2a238c269802de0"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:ad9d6731fd32b1a4ab2a238c269802de0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#ad9d6731fd32b1a4ab2a238c269802de0">is_storage_pointer</a> (typename <a class="el" href="nrnoc_2cabvars_8h.html#acd579dfd50a9ea905ca697ed8707bf3b">Tag::type</a> const *ptr) const</td></tr>
<tr class="memdesc:ad9d6731fd32b1a4ab2a238c269802de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the given pointer-to-vector is the one associated to Tag.  <a href="structneuron_1_1container_1_1soa.html#ad9d6731fd32b1a4ab2a238c269802de0">More...</a><br /></td></tr>
<tr class="separator:ad9d6731fd32b1a4ab2a238c269802de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3290d1dbf9d0e819b7ff8e9d5873c6b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structneuron_1_1container_1_1utils_1_1storage__info.html">utils::storage_info</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#aa3290d1dbf9d0e819b7ff8e9d5873c6b">find_container_info</a> (void const *cont) const</td></tr>
<tr class="memdesc:aa3290d1dbf9d0e819b7ff8e9d5873c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>cont</code> refers to a field in this container.  <a href="structneuron_1_1container_1_1soa.html#aa3290d1dbf9d0e819b7ff8e9d5873c6b">More...</a><br /></td></tr>
<tr class="separator:aa3290d1dbf9d0e819b7ff8e9d5873c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf9715572b1752ed96a9371b6735309"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:aadf9715572b1752ed96a9371b6735309"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="nrnoc_2cabvars_8h.html#acd579dfd50a9ea905ca697ed8707bf3b">Tag::type</a> *const  *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#aadf9715572b1752ed96a9371b6735309">get_data_ptrs</a> () const</td></tr>
<tr class="memdesc:aadf9715572b1752ed96a9371b6735309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to a range of pointers that always point to the start of the contiguous storage.  <a href="structneuron_1_1container_1_1soa.html#aadf9715572b1752ed96a9371b6735309">More...</a><br /></td></tr>
<tr class="separator:aadf9715572b1752ed96a9371b6735309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0973e0019811129fb2b14402390c34cd"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:a0973e0019811129fb2b14402390c34cd"><td class="memTemplItemLeft" align="right" valign="top">int const  *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a0973e0019811129fb2b14402390c34cd">get_array_dims</a> () const</td></tr>
<tr class="memdesc:a0973e0019811129fb2b14402390c34cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to an array holding the array dimensions of the fields associated with this tag.  <a href="structneuron_1_1container_1_1soa.html#a0973e0019811129fb2b14402390c34cd">More...</a><br /></td></tr>
<tr class="separator:a0973e0019811129fb2b14402390c34cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95ab7c5527e743471b9e5499a05d2df"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:ae95ab7c5527e743471b9e5499a05d2df"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#ae95ab7c5527e743471b9e5499a05d2df">get_array_dims</a> (int <a class="el" href="structneuron_1_1container_1_1field__index.html">field_index</a>) const</td></tr>
<tr class="separator:ae95ab7c5527e743471b9e5499a05d2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06c27dd9a41cbf19eb8acbc58f650c1"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:ad06c27dd9a41cbf19eb8acbc58f650c1"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#ad06c27dd9a41cbf19eb8acbc58f650c1">get_num_variables</a> () const</td></tr>
<tr class="separator:ad06c27dd9a41cbf19eb8acbc58f650c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c314cd0389fcb1a70a51f737ce7c732"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:a2c314cd0389fcb1a70a51f737ce7c732"><td class="memTemplItemLeft" align="right" valign="top">int const  *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a2c314cd0389fcb1a70a51f737ce7c732">get_array_dim_prefix_sums</a> () const</td></tr>
<tr class="memdesc:a2c314cd0389fcb1a70a51f737ce7c732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to an array holding the prefix sum of array dimensions for this tag.  <a href="structneuron_1_1container_1_1soa.html#a2c314cd0389fcb1a70a51f737ce7c732">More...</a><br /></td></tr>
<tr class="separator:a2c314cd0389fcb1a70a51f737ce7c732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecce0afdf5b38f002dbb488b27d73b0d"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:aecce0afdf5b38f002dbb488b27d73b0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structneuron_1_1container_1_1field__index.html">field_index</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#aecce0afdf5b38f002dbb488b27d73b0d">translate_legacy_index</a> (int legacy_index) const</td></tr>
<tr class="separator:aecce0afdf5b38f002dbb488b27d73b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e95645a8feeb8f7306fd11bab9c280"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:a29e95645a8feeb8f7306fd11bab9c280"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a29e95645a8feeb8f7306fd11bab9c280">field_active</a> () const</td></tr>
<tr class="memdesc:a29e95645a8feeb8f7306fd11bab9c280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the field associated with the given tag is active.  <a href="structneuron_1_1container_1_1soa.html#a29e95645a8feeb8f7306fd11bab9c280">More...</a><br /></td></tr>
<tr class="separator:a29e95645a8feeb8f7306fd11bab9c280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b63bc06fd763ab5d7b335a2cb054de"><td class="memTemplParams" colspan="2">template&lt;typename... TagsToChange&gt; </td></tr>
<tr class="memitem:af0b63bc06fd763ab5d7b335a2cb054de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#af0b63bc06fd763ab5d7b335a2cb054de">set_field_status</a> (bool enabled)</td></tr>
<tr class="memdesc:af0b63bc06fd763ab5d7b335a2cb054de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable the fields associated with the given tags.  <a href="structneuron_1_1container_1_1soa.html#af0b63bc06fd763ab5d7b335a2cb054de">More...</a><br /></td></tr>
<tr class="separator:af0b63bc06fd763ab5d7b335a2cb054de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3932b78ba8d2f552065138112ffb249"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structneuron_1_1container_1_1_storage_memory_usage.html">StorageMemoryUsage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#af3932b78ba8d2f552065138112ffb249">memory_usage</a> () const</td></tr>
<tr class="separator:af3932b78ba8d2f552065138112ffb249"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a84dd3d332c780b4beeaa6e688c9abc74"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:a84dd3d332c780b4beeaa6e688c9abc74"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a84dd3d332c780b4beeaa6e688c9abc74">has_tag_v</a> = <a class="el" href="namespaceneuron_1_1container_1_1detail.html#a622cde7d1394104887ce8a7390509512">detail::type_in_pack_v</a>&lt;Tag, Tags...&gt;</td></tr>
<tr class="separator:a84dd3d332c780b4beeaa6e688c9abc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a3f4bc1c863c67299d8f1d657a7523060"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a3f4bc1c863c67299d8f1d657a7523060">erase</a> (std::size_t <a class="el" href="seclist_8cpp.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>)</td></tr>
<tr class="memdesc:a3f4bc1c863c67299d8f1d657a7523060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the \(i^{\text{th}}\) row from the container.  <a href="structneuron_1_1container_1_1soa.html#a3f4bc1c863c67299d8f1d657a7523060">More...</a><br /></td></tr>
<tr class="separator:a3f4bc1c863c67299d8f1d657a7523060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff6aa03a02c5be1321b996df61b0ead"><td class="memTemplParams" colspan="2">template&lt;detail::may_cause_reallocation might_reallocate, typename Callable &gt; </td></tr>
<tr class="memitem:afff6aa03a02c5be1321b996df61b0ead"><td class="memTemplItemLeft" align="right" valign="top">Callable&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#afff6aa03a02c5be1321b996df61b0ead">for_each_vector</a> (Callable callable)</td></tr>
<tr class="memdesc:afff6aa03a02c5be1321b996df61b0ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the given function to non-const versions of all vectors.  <a href="structneuron_1_1container_1_1soa.html#afff6aa03a02c5be1321b996df61b0ead">More...</a><br /></td></tr>
<tr class="separator:afff6aa03a02c5be1321b996df61b0ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad7d342cbd7e277a6abc3288a919c63"><td class="memTemplParams" colspan="2">template&lt;detail::may_cause_reallocation might_reallocate, typename Callable , typename Tag , typename... RemainingTags&gt; </td></tr>
<tr class="memitem:acad7d342cbd7e277a6abc3288a919c63"><td class="memTemplItemLeft" align="right" valign="top">Callable&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#acad7d342cbd7e277a6abc3288a919c63">for_each_tag_vector_impl</a> (Callable callable)</td></tr>
<tr class="separator:acad7d342cbd7e277a6abc3288a919c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e19a0462d60dead163f46def1a1be2"><td class="memTemplParams" colspan="2">template&lt;detail::may_cause_reallocation , typename Callable &gt; </td></tr>
<tr class="memitem:ac8e19a0462d60dead163f46def1a1be2"><td class="memTemplItemLeft" align="right" valign="top">Callable&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#ac8e19a0462d60dead163f46def1a1be2">for_each_tag_vector_impl</a> (Callable callable)</td></tr>
<tr class="separator:ac8e19a0462d60dead163f46def1a1be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2170f8bd2c48041a13023bd409d3fa40"><td class="memTemplParams" colspan="2">template&lt;typename Callable &gt; </td></tr>
<tr class="memitem:a2170f8bd2c48041a13023bd409d3fa40"><td class="memTemplItemLeft" align="right" valign="top">Callable&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a2170f8bd2c48041a13023bd409d3fa40">for_each_vector</a> (Callable callable) const</td></tr>
<tr class="memdesc:a2170f8bd2c48041a13023bd409d3fa40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the given function to const-qualified versions of all vectors.  <a href="structneuron_1_1container_1_1soa.html#a2170f8bd2c48041a13023bd409d3fa40">More...</a><br /></td></tr>
<tr class="separator:a2170f8bd2c48041a13023bd409d3fa40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971362a1b4998e9834314cb297a24f7b"><td class="memTemplParams" colspan="2">template&lt;typename Callable , typename Tag , typename... RemainingTags&gt; </td></tr>
<tr class="memitem:a971362a1b4998e9834314cb297a24f7b"><td class="memTemplItemLeft" align="right" valign="top">Callable&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a971362a1b4998e9834314cb297a24f7b">for_each_tag_vector_impl</a> (Callable callable) const</td></tr>
<tr class="separator:a971362a1b4998e9834314cb297a24f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73825465b118d1d83c36aa0fd49f14de"><td class="memTemplParams" colspan="2">template&lt;typename Callable &gt; </td></tr>
<tr class="memitem:a73825465b118d1d83c36aa0fd49f14de"><td class="memTemplItemLeft" align="right" valign="top">Callable&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a73825465b118d1d83c36aa0fd49f14de">for_each_tag_vector_impl</a> (Callable callable) const</td></tr>
<tr class="separator:a73825465b118d1d83c36aa0fd49f14de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a80e735c709d851abfc8a688655591"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a46a80e735c709d851abfc8a688655591">increase_frozen_count</a> ()</td></tr>
<tr class="memdesc:a46a80e735c709d851abfc8a688655591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that a <a class="el" href="structneuron_1_1container_1_1state__token.html" title="Token whose lifetime manages the frozen state of a container.">state_token</a> was copied.  <a href="structneuron_1_1container_1_1soa.html#a46a80e735c709d851abfc8a688655591">More...</a><br /></td></tr>
<tr class="separator:a46a80e735c709d851abfc8a688655591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a037497b4320ccf96968c2fca4ee75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a43a037497b4320ccf96968c2fca4ee75">decrease_frozen_count</a> ()</td></tr>
<tr class="memdesc:a43a037497b4320ccf96968c2fca4ee75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag that the storage is no longer frozen.  <a href="structneuron_1_1container_1_1soa.html#a43a037497b4320ccf96968c2fca4ee75">More...</a><br /></td></tr>
<tr class="separator:a43a037497b4320ccf96968c2fca4ee75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffcbd889567df799e515c58f7e93ccd"><td class="memTemplParams" colspan="2">template&lt;bool internal&gt; </td></tr>
<tr class="memitem:a0ffcbd889567df799e515c58f7e93ccd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a0ffcbd889567df799e515c58f7e93ccd">mark_as_unsorted_impl</a> ()</td></tr>
<tr class="memdesc:a0ffcbd889567df799e515c58f7e93ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set m_sorted = false and execute the callback.  <a href="structneuron_1_1container_1_1soa.html#a0ffcbd889567df799e515c58f7e93ccd">More...</a><br /></td></tr>
<tr class="separator:a0ffcbd889567df799e515c58f7e93ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0802391f43dd5670920b8f0c03ca434f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structneuron_1_1container_1_1owning__identifier.html">owning_identifier</a>&lt; Storage &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a0802391f43dd5670920b8f0c03ca434f">acquire_owning_identifier</a> ()</td></tr>
<tr class="memdesc:a0802391f43dd5670920b8f0c03ca434f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new entry and return an identifier that owns it.  <a href="structneuron_1_1container_1_1soa.html#a0802391f43dd5670920b8f0c03ca434f">More...</a><br /></td></tr>
<tr class="separator:a0802391f43dd5670920b8f0c03ca434f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7ad235bacff0f913303372dba9005e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a9a7ad235bacff0f913303372dba9005e">throw_error</a> (std::string_view message) const</td></tr>
<tr class="memdesc:a9a7ad235bacff0f913303372dba9005e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception with a pretty prefix.  <a href="structneuron_1_1container_1_1soa.html#a9a7ad235bacff0f913303372dba9005e">More...</a><br /></td></tr>
<tr class="separator:a9a7ad235bacff0f913303372dba9005e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a83ce8fb5d0c22664284f404f4e6c0fe9"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a83ce8fb5d0c22664284f404f4e6c0fe9">m_mut</a> {}</td></tr>
<tr class="memdesc:a83ce8fb5d0c22664284f404f4e6c0fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to protect m_frozen_count and m_sorted.  <a href="structneuron_1_1container_1_1soa.html#a83ce8fb5d0c22664284f404f4e6c0fe9">More...</a><br /></td></tr>
<tr class="separator:a83ce8fb5d0c22664284f404f4e6c0fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada913a061d655afe9ace8c6a8533108d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#ada913a061d655afe9ace8c6a8533108d">m_sorted</a> {false}</td></tr>
<tr class="memdesc:ada913a061d655afe9ace8c6a8533108d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for <a class="el" href="structneuron_1_1container_1_1soa.html#a54b3da5eeb40d7038f4eac42fc53dd05" title="Create a token guaranteeing the container is in &quot;frozen&quot; state.">issue_frozen_token()</a>, <a class="el" href="structneuron_1_1container_1_1soa.html#a908668b49668da296f5ee09974f223f8" title="Tell the container it is no longer sorted.">mark_as_unsorted()</a> and <a class="el" href="structneuron_1_1container_1_1soa.html#a10aee5bc82e78fbfe2932ee36fce57f2" title="Query if the underlying vectors are still &quot;sorted&quot;.">is_sorted()</a>.  <a href="structneuron_1_1container_1_1soa.html#ada913a061d655afe9ace8c6a8533108d">More...</a><br /></td></tr>
<tr class="separator:ada913a061d655afe9ace8c6a8533108d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42c8ca7adc69e3a69ab06b5d3ea9ae8"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#aa42c8ca7adc69e3a69ab06b5d3ea9ae8">m_frozen_count</a> {}</td></tr>
<tr class="memdesc:aa42c8ca7adc69e3a69ab06b5d3ea9ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference count for tokens guaranteeing the container is frozen.  <a href="structneuron_1_1container_1_1soa.html#aa42c8ca7adc69e3a69ab06b5d3ea9ae8">More...</a><br /></td></tr>
<tr class="separator:aa42c8ca7adc69e3a69ab06b5d3ea9ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b81db57428d526a833d652ad24bb77"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structneuron_1_1container_1_1non__owning__identifier__without__container.html">non_owning_identifier_without_container</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a80b81db57428d526a833d652ad24bb77">m_indices</a> {}</td></tr>
<tr class="memdesc:a80b81db57428d526a833d652ad24bb77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointers to identifiers that record the current physical row.  <a href="structneuron_1_1container_1_1soa.html#a80b81db57428d526a833d652ad24bb77">More...</a><br /></td></tr>
<tr class="separator:a80b81db57428d526a833d652ad24bb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57defb73f697678af5b4090ae9e8324"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="structneuron_1_1container_1_1detail_1_1field__data.html">detail::field_data</a>&lt; Tags, <a class="el" href="namespaceneuron_1_1container_1_1detail.html#a1e34c0205039b78bc52e72b7706a7fc0">detail::field_impl_v</a>&lt; Tags &gt; &gt;... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#ad57defb73f697678af5b4090ae9e8324">m_data</a> {}</td></tr>
<tr class="memdesc:ad57defb73f697678af5b4090ae9e8324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of data columns.  <a href="structneuron_1_1container_1_1soa.html#ad57defb73f697678af5b4090ae9e8324">More...</a><br /></td></tr>
<tr class="separator:ad57defb73f697678af5b4090ae9e8324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296e112ea065749bb886a332261f82c0"><td class="memItemLeft" align="right" valign="top">std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a296e112ea065749bb886a332261f82c0">m_unsorted_callback</a> {}</td></tr>
<tr class="memdesc:a296e112ea065749bb886a332261f82c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback that is invoked when the container becomes unsorted.  <a href="structneuron_1_1container_1_1soa.html#a296e112ea065749bb886a332261f82c0">More...</a><br /></td></tr>
<tr class="separator:a296e112ea065749bb886a332261f82c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:aca9e35b3df6aaca6ef52994b3a71c526"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:aca9e35b3df6aaca6ef52994b3a71c526"><td class="memTemplItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#aca9e35b3df6aaca6ef52994b3a71c526">tag_index_v</a> = <a class="el" href="namespaceneuron_1_1container_1_1detail.html#a2df65bd89a575b6662ea6941439b6009">detail::index_of_type_v</a>&lt;Tag, Tags...&gt;</td></tr>
<tr class="separator:aca9e35b3df6aaca6ef52994b3a71c526"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abb52932a3c87bf4b7c9a659b1f8d3087"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#abb52932a3c87bf4b7c9a659b1f8d3087">state_token&lt; Storage &gt;</a></td></tr>
<tr class="separator:abb52932a3c87bf4b7c9a659b1f8d3087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b8870602330fff6bc30a75d8359674"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structneuron_1_1container_1_1soa.html#a42b8870602330fff6bc30a75d8359674">owning_identifier&lt; Storage &gt;</a></td></tr>
<tr class="separator:a42b8870602330fff6bc30a75d8359674"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Storage, typename... Tags&gt;<br />
struct neuron::container::soa&lt; Storage, Tags &gt;</h3>

<p>Utility for generating SOA data structures. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Storage</td><td>Name of the actual storage type derived from soa&lt;...&gt;. </td></tr>
    <tr><td class="paramname">Tags</td><td>Parameter pack of tag types that define the columns included in the container. Types may not be repeated.</td></tr>
  </table>
  </dd>
</dl>
<p>This CRTP base class is used to implement the ~global SOA storage structs that hold (so far) <a class="el" href="namespaceneuron_1_1container_1_1_node.html">Node</a> and <a class="el" href="namespaceneuron_1_1container_1_1_mechanism.html">Mechanism</a> data. Ownership of rows in these structs is managed via instances of the owning identifier type <a class="el" href="structneuron_1_1container_1_1owning__identifier.html">neuron::container::owning_identifier</a> instantiated with Storage, and non-owning reference to rows in the data structures are managed via instances of the <a class="el" href="structneuron_1_1container_1_1non__owning__identifier.html">neuron::container::non_owning_identifier</a> template instantiated with Storage. These identifiers are typically wrapped in a data-structure-specific (i.e. Node- or Mechanism-specific) interface type that provides data-structure-specific accessors and methods to obtain actual data values and more generic handle types such as <a class="el" href="structneuron_1_1container_1_1data__handle.html">neuron::container::data_handle&lt;T&gt;</a> and <a class="el" href="structneuron_1_1container_1_1generic__data__handle.html">neuron::container::generic_data_handle</a>. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l00683">683</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a803693e65c0bece85c5c1399c7894689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803693e65c0bece85c5c1399c7894689">&#9670;&nbsp;</a></span>frozen_token_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::<a class="el" href="structneuron_1_1container_1_1soa.html#a803693e65c0bece85c5c1399c7894689">frozen_token_type</a> =  <a class="el" href="structneuron_1_1container_1_1state__token.html">state_token</a>&lt;Storage&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return type of <a class="el" href="structneuron_1_1container_1_1soa.html#a54b3da5eeb40d7038f4eac42fc53dd05" title="Create a token guaranteeing the container is in &quot;frozen&quot; state.">issue_frozen_token()</a> </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l00923">923</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acbc4471c3453a1ff74e34d395524b331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbc4471c3453a1ff74e34d395524b331">&#9670;&nbsp;</a></span>soa() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::<a class="el" href="structneuron_1_1container_1_1soa.html">soa</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct with default-constructed tag type instances. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l00687">687</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a87a6493673231f25b2d612aa180ea305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a6493673231f25b2d612aa180ea305">&#9670;&nbsp;</a></span>soa() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::<a class="el" href="structneuron_1_1container_1_1soa.html">soa</a> </td>
          <td>(</td>
          <td class="paramtype">Tags...&#160;</td>
          <td class="paramname"><em>tag_instances</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct with specific tag instances. </p>
<p>This is useful if the tag types are not empty, for example if the number of times a column is duplicated is a runtime value. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l00696">696</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a21bc8880ea57b2a84704d24f57e04d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21bc8880ea57b2a84704d24f57e04d33">&#9670;&nbsp;</a></span>soa() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::<a class="el" href="structneuron_1_1container_1_1soa.html">soa</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structneuron_1_1container_1_1soa.html">soa</a>&lt; Storage, Tags &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structneuron_1_1container_1_1soa.html">soa</a> is not movable </p>
<p>This is to make it harder to accidentally invalidate pointers-to-storage in handles. </p>

</div>
</div>
<a id="a2321012aed74c4a98b7b177e21009ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2321012aed74c4a98b7b177e21009ee7">&#9670;&nbsp;</a></span>soa() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::<a class="el" href="structneuron_1_1container_1_1soa.html">soa</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structneuron_1_1container_1_1soa.html">soa</a>&lt; Storage, Tags &gt; const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structneuron_1_1container_1_1soa.html">soa</a> is not copiable </p>
<p>This is partly to make it harder to accidentally invalidate pointers-to-storage in handles, and partly because it could be very expensive so it might be better to be more explicit. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0802391f43dd5670920b8f0c03ca434f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0802391f43dd5670920b8f0c03ca434f">&#9670;&nbsp;</a></span>acquire_owning_identifier()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structneuron_1_1container_1_1owning__identifier.html">owning_identifier</a>&lt;Storage&gt; <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::acquire_owning_identifier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new entry and return an identifier that owns it. </p>
<p>Calling this method increases <a class="el" href="structneuron_1_1container_1_1soa.html#a567b1b33e63684c03113e2358bcadb04" title="Get the size of the container.">size()</a> by one. Destroying (modulo move operations) the returned identifier, which has the semantics of a unique_ptr, decreases <a class="el" href="structneuron_1_1container_1_1soa.html#a567b1b33e63684c03113e2358bcadb04" title="Get the size of the container.">size()</a> by one.</p>
<p>Note that this has different semantics to standard library container methods such as emplace_back(), push_back(), <a class="el" href="namespacecoreneuron_1_1scopmath_1_1sparse.html#a5b8e96944a7b86ed26e9b02ce4a451c8">insert()</a> and so on. Because the returned identifier manages the lifetime of the newly-created entry, discarding the return value will cause the new entry to immediately be deleted.</p>
<p>This is a low-level call that is useful for the implementation of the <a class="el" href="structneuron_1_1container_1_1owning__identifier.html" title="An owning permutation-stable identifier for a entry in a container.">owning_identifier</a> template. The returned owning identifier is typically wrapped inside an owning handle type that adds data-structure-specific methods (e.g. <a class="el" href="coreneuron_2nrnoc_2md1redef_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">v()</a>, v_handle() for a <a class="el" href="namespaceneuron_1_1container_1_1_node.html">Node</a>). </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01153">1153</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="ad5aae504ab331f98fe7e16511bd5638d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5aae504ab331f98fe7e16511bd5638d">&#9670;&nbsp;</a></span>apply_reverse_permutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename Arg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structneuron_1_1container_1_1soa.html#a803693e65c0bece85c5c1399c7894689">frozen_token_type</a> <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::apply_reverse_permutation </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>permutation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permute the SoA-format data using an arbitrary range of integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">permutation</td><td>The reverse permutation vector to apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A token guaranteeing the frozen + sorted state of the container after the permutation was applied.</dd></dl>
<p>This will fail if the container is frozen. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01045">1045</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a955cd5e607f0877a85fc38174af11d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955cd5e607f0877a85fc38174af11d17">&#9670;&nbsp;</a></span>apply_reverse_permutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename Range &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::apply_reverse_permutation </td>
          <td>(</td>
          <td class="paramtype">Range&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structneuron_1_1container_1_1soa.html#a803693e65c0bece85c5c1399c7894689">frozen_token_type</a> &amp;&#160;</td>
          <td class="paramname"><em>sorted_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permute the SoA-format data using an arbitrary range of integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">permutation</td><td>The reverse permutation vector to apply. </td></tr>
    <tr><td class="paramname">token</td><td>A non-const token demonstrating that the caller is the only party that is forcing the container to be frozen, and (non-const) that they are authorised to transfer that status into this method </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01059">1059</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a8cc0940857c918c76dc67ef8eb8da8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc0940857c918c76dc67ef8eb8da8fe">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structneuron_1_1container_1_1non__owning__identifier.html">non_owning_identifier</a>&lt;Storage&gt; <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::at </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a non-owning identifier to the offset-th entry. </p>
<p>This method should only be called if either: there is only one thread, or if a frozen token is held. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01195">1195</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a43a037497b4320ccf96968c2fca4ee75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a037497b4320ccf96968c2fca4ee75">&#9670;&nbsp;</a></span>decrease_frozen_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::decrease_frozen_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag that the storage is no longer frozen. </p>
<p>This is called from the destructor of <a class="el" href="structneuron_1_1container_1_1state__token.html" title="Token whose lifetime manages the frozen state of a container.">state_token</a>. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l00913">913</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="ad67063379b06b305c5717832c255c7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67063379b06b305c5717832c255c7f7">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the container is empty. </p>
<p>Note that this is not thread-safe if the container is not frozen, i.e. you should either hold a token showing the container is frozen, or you should ensure that no non-const operations on this container are being executed concurrently. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l00759">759</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a3f4bc1c863c67299d8f1d657a7523060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4bc1c863c67299d8f1d657a7523060">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the \(i^{\text{th}}\) row from the container. </p>
<p>This is currently implemented by swapping the last element into position \(i\) (if those are not the same element) and reducing the size by one. Iterators to the last element and the deleted element will be invalidated. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l00786">786</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a29e95645a8feeb8f7306fd11bab9c280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e95645a8feeb8f7306fd11bab9c280">&#9670;&nbsp;</a></span>field_active()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::field_active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether the field associated with the given tag is active. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01525">1525</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="aa3290d1dbf9d0e819b7ff8e9d5873c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3290d1dbf9d0e819b7ff8e9d5873c6b">&#9670;&nbsp;</a></span>find_container_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="structneuron_1_1container_1_1utils_1_1storage__info.html">utils::storage_info</a>&gt; <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::find_container_info </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <code>cont</code> refers to a field in this container. </p>
<p>This is not intended to be called from multi-threaded code if the container is not frozen. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01450">1450</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a5c391ab9bb358f5ca8a72512fcdbcf64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c391ab9bb358f5ca8a72512fcdbcf64">&#9670;&nbsp;</a></span>find_data_handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structneuron_1_1container_1_1generic__data__handle.html">neuron::container::generic_data_handle</a> <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::find_data_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structneuron_1_1container_1_1generic__data__handle.html">neuron::container::generic_data_handle</a>&#160;</td>
          <td class="paramname"><em>input_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a permutation-stable handle if ptr is inside us. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd>Check const-correctness. Presumably a const version would return data_handle&lt;T const&gt;, which would hold a pointer-to-const for the container?</dd></dl>
<p>This is not intended to be called from multi-threaded code if the container is not frozen. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01380">1380</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="acad7d342cbd7e277a6abc3288a919c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad7d342cbd7e277a6abc3288a919c63">&#9670;&nbsp;</a></span>for_each_tag_vector_impl() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;detail::may_cause_reallocation might_reallocate, typename Callable , typename Tag , typename... RemainingTags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Callable <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::for_each_tag_vector_impl </td>
          <td>(</td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l00851">851</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="ac8e19a0462d60dead163f46def1a1be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e19a0462d60dead163f46def1a1be2">&#9670;&nbsp;</a></span>for_each_tag_vector_impl() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;detail::may_cause_reallocation , typename Callable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Callable <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::for_each_tag_vector_impl </td>
          <td>(</td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l00858">858</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a971362a1b4998e9834314cb297a24f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971362a1b4998e9834314cb297a24f7b">&#9670;&nbsp;</a></span>for_each_tag_vector_impl() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename Callable , typename Tag , typename... RemainingTags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Callable <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::for_each_tag_vector_impl </td>
          <td>(</td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l00884">884</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a73825465b118d1d83c36aa0fd49f14de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73825465b118d1d83c36aa0fd49f14de">&#9670;&nbsp;</a></span>for_each_tag_vector_impl() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename Callable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Callable <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::for_each_tag_vector_impl </td>
          <td>(</td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l00891">891</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="afff6aa03a02c5be1321b996df61b0ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff6aa03a02c5be1321b996df61b0ead">&#9670;&nbsp;</a></span>for_each_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;detail::may_cause_reallocation might_reallocate, typename Callable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Callable <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::for_each_vector </td>
          <td>(</td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the given function to non-const versions of all vectors. </p>
<p>The callable has a signature compatible with: </p><pre class="fragment">void callable(const Tag&amp; tag,
              std::vector&lt;Tag::data_type, Allocator&gt;&amp; v,
              int field_index,
              int array_dim)
</pre><p>where <code>array_dim</code> is the array dimensions of the field <code><a class="el" href="structneuron_1_1container_1_1field__index.html" title="Struct used to index SoAoS data, such as array range variables.">field_index</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">might_reallocate</td><td>Might the callable trigger reallocation of the vectors? </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>Callable to invoke on each vector.</td></tr>
  </table>
  </dd>
</dl>
<p>If might_allocate is true then the "cached" values of .<a class="el" href="coreneuron_2nrnoc_2md1redef_8h.html#a43a278d13284fb3412e9eee1db1d967e">data()</a> for each vector will be updated. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l00839">839</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a2170f8bd2c48041a13023bd409d3fa40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2170f8bd2c48041a13023bd409d3fa40">&#9670;&nbsp;</a></span>for_each_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename Callable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Callable <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::for_each_vector </td>
          <td>(</td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the given function to const-qualified versions of all vectors. </p>
<p>The callable has a signature compatible with: </p><pre class="fragment">void callable(const Tag&amp; tag,
              const std::vector&lt;Tag::data_type, Allocator&gt;&amp; v,
              int field_index,
              int array_dim)
</pre><p>where <code>array_dim</code> is the array dimensions of the field <code><a class="el" href="structneuron_1_1container_1_1field__index.html" title="Struct used to index SoAoS data, such as array range variables.">field_index</a></code>.</p>
<p>Because of the const qualification this cannot cause reallocation and trigger updates of pointers inside m_data, so no might_reallocate parameter is needed. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l00878">878</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a52fd7c9f91056d8249cc17d514ef0a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52fd7c9f91056d8249cc17d514ef0a3b">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nrnoc_2cabvars_8h.html#acd579dfd50a9ea905ca697ed8707bf3b">Tag::type</a>&amp; <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::get </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the offset-th element of the column named by Tag. </p>
<p>Because this is returning a single value, it is permitted even when the container is frozen. The container being frozen means that operations that would invalidate iterators/pointers are forbidden, not that actual data values cannot change. Note that if the container is not frozen then care should be taken in a multi-threaded environment, as <code>offset</code> could be invalidated by operations performed by other threads (that would fail if the container were frozen). </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01233">1233</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="ad601f80f6b0531a3877a2fd9c8230a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad601f80f6b0531a3877a2fd9c8230a2b">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nrnoc_2cabvars_8h.html#acd579dfd50a9ea905ca697ed8707bf3b">Tag::type</a> const&amp; <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::get </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the offset-th element of the column named by Tag. </p>
<p>If the container is not frozen then care should be taken in a multi-threaded environment, as <code>offset</code> could be invalidated by operations performed by other threads (that would fail if the container were frozen). </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01255">1255</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a2c314cd0389fcb1a70a51f737ce7c732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c314cd0389fcb1a70a51f737ce7c732">&#9670;&nbsp;</a></span>get_array_dim_prefix_sums()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int const* <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::get_array_dim_prefix_sums </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to an array holding the prefix sum of array dimensions for this tag. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01512">1512</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a0973e0019811129fb2b14402390c34cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0973e0019811129fb2b14402390c34cd">&#9670;&nbsp;</a></span>get_array_dims() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int const* <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::get_array_dims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to an array holding the array dimensions of the fields associated with this tag. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01493">1493</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="ae95ab7c5527e743471b9e5499a05d2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae95ab7c5527e743471b9e5499a05d2df">&#9670;&nbsp;</a></span>get_array_dims() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::get_array_dims </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>field_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01498">1498</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="aadf9715572b1752ed96a9371b6735309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf9715572b1752ed96a9371b6735309">&#9670;&nbsp;</a></span>get_data_ptrs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nrnoc_2cabvars_8h.html#acd579dfd50a9ea905ca697ed8707bf3b">Tag::type</a>* const* <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::get_data_ptrs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to a range of pointers that always point to the start of the contiguous storage. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01484">1484</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a471881081c25cf7aea38a4cdc3c8c8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471881081c25cf7aea38a4cdc3c8c8d5">&#9670;&nbsp;</a></span>get_field_instance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nrnoc_2cabvars_8h.html#acd579dfd50a9ea905ca697ed8707bf3b">Tag::type</a>&amp; <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::get_field_instance </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>field_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>array_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the offset-th element of the field_index-th instance of the column named by Tag. </p>
<p>Put differently:</p><ul>
<li>offset: index of a mechanism instance</li>
<li><a class="el" href="structneuron_1_1container_1_1field__index.html" title="Struct used to index SoAoS data, such as array range variables.">field_index</a>: index of a RANGE variable inside a mechanism</li>
<li>array_index: offset inside an array RANGE variable</li>
</ul>
<p>Because this is returning a single value, it is permitted even when the container is frozen. The container being frozen means that operations that would invalidate iterators/pointers are forbidden, not that actual data values cannot change. Note that if the container is not frozen then care should be taken in a multi-threaded environment, as <code>offset</code> could be invalidated by operations performed by other threads (that would fail if the container were frozen). </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01332">1332</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="ad7aca35ebbb8003945b0f2ab59eb777b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7aca35ebbb8003945b0f2ab59eb777b">&#9670;&nbsp;</a></span>get_field_instance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nrnoc_2cabvars_8h.html#acd579dfd50a9ea905ca697ed8707bf3b">Tag::type</a> const&amp; <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::get_field_instance </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>field_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>array_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the offset-th element of the field_index-th instance of the column named by Tag. </p>
<p>If the container is not frozen then care should be taken in a multi-threaded environment, as <code>offset</code> could be invalidated by operations performed by other threads (that would fail if the container were frozen). </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01350">1350</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="afa8daed8465bd3f74ab7fd9ba1d86c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8daed8465bd3f74ab7fd9ba1d86c07">&#9670;&nbsp;</a></span>get_field_instance_handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structneuron_1_1container_1_1data__handle.html">data_handle</a>&lt;typename <a class="el" href="nrnoc_2cabvars_8h.html#acd579dfd50a9ea905ca697ed8707bf3b">Tag::type</a>&gt; <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::get_field_instance_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structneuron_1_1container_1_1non__owning__identifier__without__container.html">non_owning_identifier_without_container</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>field_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>array_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a handle to the given element of the field_index-th column named by Tag. </p>
<p>This is not intended to be called from multi-threaded code. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01301">1301</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="ada0490ded7230ec2a83ec1e6fc8f6644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0490ded7230ec2a83ec1e6fc8f6644">&#9670;&nbsp;</a></span>get_handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structneuron_1_1container_1_1data__handle.html">data_handle</a>&lt;typename <a class="el" href="nrnoc_2cabvars_8h.html#acd579dfd50a9ea905ca697ed8707bf3b">Tag::type</a>&gt; <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::get_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structneuron_1_1container_1_1non__owning__identifier__without__container.html">non_owning_identifier_without_container</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>array_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a handle to the given element of the column named by Tag. </p>
<p>This is not intended to be called from multi-threaded code, and might suffer from race conditions if the status of optional fields was being modified concurrently. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01276">1276</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="aa3e745d863fd672f1380f981a0f213b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e745d863fd672f1380f981a0f213b0">&#9670;&nbsp;</a></span>get_identifier()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structneuron_1_1container_1_1non__owning__identifier__without__container.html">non_owning_identifier_without_container</a> <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::get_identifier </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the offset-th identifier. </p>
<p>If the container is not frozen then care should be taken in a multi-threaded environment, as <code>offset</code> could be invalidated by operations performed by other threads (that would fail if the container were frozen). </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01367">1367</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="ad06c27dd9a41cbf19eb8acbc58f650c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06c27dd9a41cbf19eb8acbc58f650c1">&#9670;&nbsp;</a></span>get_num_variables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::get_num_variables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01504">1504</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a8c1ad473fc9cca00cd3378c12bc99b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1ad473fc9cca00cd3378c12bc99b91">&#9670;&nbsp;</a></span>get_tag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Tag const&amp; <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::get_tag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the instance of the given tag type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tag</td><td>The tag type, which must be a member of the <code>Tags</code>... pack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the given tag type instance.</dd></dl>
<p>For example, if this is called on the <code><a class="el" href="structneuron_1_1container_1_1_node_1_1storage.html" title="Underlying storage for all Nodes.">Node::storage</a></code> then <code>Tag</code> would be something like <code><a class="el" href="structneuron_1_1container_1_1_node_1_1field_1_1_area.html" title="Area in um^2 but see treeset.cpp.">Node::field::Area</a></code>, <code><a class="el" href="structneuron_1_1container_1_1_node_1_1field_1_1_r_h_s.html">Node::field::RHS</a></code> or <code><a class="el" href="structneuron_1_1container_1_1_node_1_1field_1_1_voltage.html" title="Membrane potential.">Node::field::Voltage</a></code>, which are empty types that serve to define the default values and types of those quantities.</p>
<p>At the time of writing the other possibility is that this is called on an instance of <code><a class="el" href="structneuron_1_1container_1_1_mechanism_1_1storage.html" title="Underlying storage for all instances of a particular Mechanism.">Mechanism::storage</a></code>, in which case <code>Tag</code> must (currently) be <code><a class="el" href="structneuron_1_1container_1_1_mechanism_1_1field_1_1_floating_point.html" title="Catch-all for floating point per-instance variables in the MOD file.">Mechanism::field::FloatingPoint</a></code>. This stores the names and array dimensions of the RANGE variables in the mechanism (MOD file), which are only known at runtime. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01214">1214</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a46a80e735c709d851abfc8a688655591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a80e735c709d851abfc8a688655591">&#9670;&nbsp;</a></span>increase_frozen_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::increase_frozen_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Record that a <a class="el" href="structneuron_1_1container_1_1state__token.html" title="Token whose lifetime manages the frozen state of a container.">state_token</a> was copied. </p>
<p>This should only be called from the copy constructor of a <a class="el" href="structneuron_1_1container_1_1state__token.html" title="Token whose lifetime manages the frozen state of a container.">state_token</a>, so m_frozen_count should already be non-zero. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l00902">902</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a10aee5bc82e78fbfe2932ee36fce57f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10aee5bc82e78fbfe2932ee36fce57f2">&#9670;&nbsp;</a></span>is_sorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::is_sorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query if the underlying vectors are still "sorted". </p>
<p>See the documentation of <a class="el" href="structneuron_1_1container_1_1soa.html#a54b3da5eeb40d7038f4eac42fc53dd05" title="Create a token guaranteeing the container is in &quot;frozen&quot; state.">issue_frozen_token()</a> for an explanation of what this means. You most likely only want to call this method while holding a token guaranteeing that the container is frozen, and therefore that the sorted-status is fixed. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01032">1032</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="ad9d6731fd32b1a4ab2a238c269802de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d6731fd32b1a4ab2a238c269802de0">&#9670;&nbsp;</a></span>is_storage_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::is_storage_pointer </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="nrnoc_2cabvars_8h.html#acd579dfd50a9ea905ca697ed8707bf3b">Tag::type</a> const *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether the given pointer-to-vector is the one associated to Tag. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd>Fix this for tag types with num_variables()?</dd></dl>
<p>This is used so that one can ask a data_handle&lt;T&gt; if it refers to a particular field in a particular container. It is not intended to be called from multi-threaded code if the container is not frozen. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01431">1431</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a54b3da5eeb40d7038f4eac42fc53dd05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b3da5eeb40d7038f4eac42fc53dd05">&#9670;&nbsp;</a></span>issue_frozen_token()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structneuron_1_1container_1_1soa.html#a803693e65c0bece85c5c1399c7894689">frozen_token_type</a> <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::issue_frozen_token </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a token guaranteeing the container is in "frozen" state. </p>
<p>This does <em>not</em> modify the "sorted" flag on the container.</p>
<p>The token type is copy constructible but not default constructible. There is no need to check if a given instance of the token type is "valid"; if a token is held then the container is guaranteed to be frozen.</p>
<p>The tokens returned by this function are reference counted; the container will be frozen for as long as any token is alive.</p>
<p>Methods such as <a class="el" href="structneuron_1_1container_1_1soa.html#ad5aae504ab331f98fe7e16511bd5638d" title="Permute the SoA-format data using an arbitrary range of integers.">apply_reverse_permutation()</a> take a non-const reference to one of these tokens. This is because a non-const token referring to a container with a token reference count of exactly one has an elevated status: the holder can lend it out to methods such as <a class="el" href="structneuron_1_1container_1_1soa.html#ad5aae504ab331f98fe7e16511bd5638d" title="Permute the SoA-format data using an arbitrary range of integers.">apply_reverse_permutation()</a> to authorize specific pointer-invaliding operations. This is useful for implementing methods such as <a class="el" href="nrn__ansi_8h.html#af4cd27306dce6814958b7c50a8a3e248" title="Ensure neuron::container::* data are sorted.">nrn_ensure_model_data_are_sorted()</a> in a thread-safe way.</p>
<p>This method can be called from multiple threads, but note that doing so can have surprising effects w.r.t. the elevated status mentioned in the previous paragraph.</p>
<p>It is user-defined precisely what "sorted" means, but the soa&lt;...&gt; class makes some guarantees:</p><ul>
<li>if the container is frozen, no pointers to elements in the underlying storage will be invalidated &ndash; attempts to do so will throw or abort.</li>
<li>if the container is not frozen, it will remain flagged as sorted until a potentially-pointer-invalidating operation (insertion, deletion) occurs, or <a class="el" href="structneuron_1_1container_1_1soa.html#a908668b49668da296f5ee09974f223f8" title="Tell the container it is no longer sorted.">mark_as_unsorted()</a> is called. To mark a container as "sorted", apply an explicit permutation to it.</li>
</ul>
<p>Note that "frozen" refers to the storage layout, not to the stored value, meaning that values inside a frozen container can still be modified &ndash; "frozen" is not "runtime const".</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>A future extension could be to preserve the sorted flag until pointers are actually, not potentially, invalidated. </dd></dl>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l00966">966</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="ac52be9084ec23bdc9e736083f7ce5264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52be9084ec23bdc9e736083f7ce5264">&#9670;&nbsp;</a></span>mark_as_sorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::mark_as_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structneuron_1_1container_1_1soa.html#a803693e65c0bece85c5c1399c7894689">frozen_token_type</a> &amp;&#160;</td>
          <td class="paramname"><em>write_token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell the container it is sorted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">write_token</td><td>Non-const token demonstrating the caller is the only token owner.</td></tr>
  </table>
  </dd>
</dl>
<p>The meaning of being sorted is externally defined, so we should give external code the opportunity to say that the current order is OK. This probably only makes sense if the external code simply doesn't care about the ordering at all for some reason. This avoids having to construct a trivial permutation vector to achieve the same thing. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l00986">986</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a908668b49668da296f5ee09974f223f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908668b49668da296f5ee09974f223f8">&#9670;&nbsp;</a></span>mark_as_unsorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::mark_as_unsorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell the container it is no longer sorted. </p>
<p>The meaning of being sorted is externally defined, and it is possible that some external change to an input of the (external) algorithm defining the sort order can mean that the data are no longer considered sorted, even if nothing has actually changed inside this container.</p>
<p>This method can only be called if the container is not frozen. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01005">1005</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a0ffcbd889567df799e515c58f7e93ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ffcbd889567df799e515c58f7e93ccd">&#9670;&nbsp;</a></span>mark_as_unsorted_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;bool internal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::mark_as_unsorted_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set m_sorted = false and execute the callback. </p>
<dl class="section note"><dt>Note</dt><dd>The <em>caller</em> is expected to hold m_mut when this is called. </dd></dl>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01118">1118</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="af3932b78ba8d2f552065138112ffb249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3932b78ba8d2f552065138112ffb249">&#9670;&nbsp;</a></span>memory_usage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structneuron_1_1container_1_1_storage_memory_usage.html">StorageMemoryUsage</a> <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::memory_usage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01542">1542</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a18a7fb9834f2ea5cf5920eb8043ccfe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a7fb9834f2ea5cf5920eb8043ccfe7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structneuron_1_1container_1_1soa.html">soa</a>&amp; <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structneuron_1_1container_1_1soa.html">soa</a>&lt; Storage, Tags &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structneuron_1_1container_1_1soa.html">soa</a> is not move assignable </p>
<p>For the same reason it isn't movable. </p>

</div>
</div>
<a id="ab6db3bae651f3ed8a62e944190b3641a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6db3bae651f3ed8a62e944190b3641a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structneuron_1_1container_1_1soa.html">soa</a>&amp; <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structneuron_1_1container_1_1soa.html">soa</a>&lt; Storage, Tags &gt; const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structneuron_1_1container_1_1soa.html">soa</a> is not copy assignable </p>
<p>For the same reasons it isn't copy constructible </p>

</div>
</div>
<a id="af0b63bc06fd763ab5d7b335a2cb054de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b63bc06fd763ab5d7b335a2cb054de">&#9670;&nbsp;</a></span>set_field_status()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename... TagsToChange&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::set_field_status </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable/disable the fields associated with the given tags. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01535">1535</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a072b58a08ca1b0d5db41e9216b9ec431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072b58a08ca1b0d5db41e9216b9ec431">&#9670;&nbsp;</a></span>set_unsorted_callback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::set_unsorted_callback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>unsorted_callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the callback that is invoked when the container becomes unsorted. </p>
<p>This is invoked by <a class="el" href="structneuron_1_1container_1_1soa.html#a908668b49668da296f5ee09974f223f8" title="Tell the container it is no longer sorted.">mark_as_unsorted()</a> and when a container operation (insertion, permutation, deletion) causes the container to transition from being sorted to being unsorted.</p>
<p>This method is not thread-safe. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01020">1020</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="aa693195c45fff0c38c735d915cc6ddb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa693195c45fff0c38c735d915cc6ddb7">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l00767">767</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a567b1b33e63684c03113e2358bcadb04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567b1b33e63684c03113e2358bcadb04">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the container. </p>
<p>Note that this is not thread-safe if the container is not frozen, i.e. you should either hold a token showing the container is frozen, or you should ensure that no non-const operations on this container are being executed concurrently. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l00738">738</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a9a7ad235bacff0f913303372dba9005e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7ad235bacff0f913303372dba9005e">&#9670;&nbsp;</a></span>throw_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::throw_error </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw an exception with a pretty prefix. </p>
<dl class="section note"><dt>Note</dt><dd>The <em>caller</em> is expected to hold m_mut when this is called. </dd></dl>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01554">1554</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="aecce0afdf5b38f002dbb488b27d73b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecce0afdf5b38f002dbb488b27d73b0d">&#9670;&nbsp;</a></span>translate_legacy_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structneuron_1_1container_1_1field__index.html">field_index</a> <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::translate_legacy_index </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>legacy_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01517">1517</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a42b8870602330fff6bc30a75d8359674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b8870602330fff6bc30a75d8359674">&#9670;&nbsp;</a></span>owning_identifier&lt; Storage &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structneuron_1_1container_1_1owning__identifier.html">owning_identifier</a>&lt; Storage &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l00814">814</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="abb52932a3c87bf4b7c9a659b1f8d3087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb52932a3c87bf4b7c9a659b1f8d3087">&#9670;&nbsp;</a></span>state_token&lt; Storage &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structneuron_1_1container_1_1state__token.html">state_token</a>&lt; Storage &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l00813">813</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a84dd3d332c780b4beeaa6e688c9abc74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84dd3d332c780b4beeaa6e688c9abc74">&#9670;&nbsp;</a></span>has_tag_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::has_tag_v = <a class="el" href="namespaceneuron_1_1container_1_1detail.html#a622cde7d1394104887ce8a7390509512">detail::type_in_pack_v</a>&lt;Tag, Tags...&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01219">1219</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="ad57defb73f697678af5b4090ae9e8324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57defb73f697678af5b4090ae9e8324">&#9670;&nbsp;</a></span>m_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="structneuron_1_1container_1_1detail_1_1field__data.html">detail::field_data</a>&lt;Tags, <a class="el" href="namespaceneuron_1_1container_1_1detail.html#a1e34c0205039b78bc52e72b7706a7fc0">detail::field_impl_v</a>&lt;Tags&gt; &gt;...&gt; <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::m_data {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collection of data columns. </p>
<p>If the tag implements a num_variables() method then it is duplicated a runtime-determined number of times and get_field_instance&lt;Tag&gt;(i) returns the i-th element of the outer vector (of length num_variables()) of vectors. If is no num_variables() method then the outer vector can be omitted and <a class="el" href="structneuron_1_1container_1_1soa.html#a52fd7c9f91056d8249cc17d514ef0a3b" title="Get the offset-th element of the column named by Tag.">get&lt;Tag&gt;()</a> returns a vector of values. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01609">1609</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="aa42c8ca7adc69e3a69ab06b5d3ea9ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42c8ca7adc69e3a69ab06b5d3ea9ae8">&#9670;&nbsp;</a></span>m_frozen_count</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::m_frozen_count {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reference count for tokens guaranteeing the container is frozen. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01593">1593</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a80b81db57428d526a833d652ad24bb77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b81db57428d526a833d652ad24bb77">&#9670;&nbsp;</a></span>m_indices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structneuron_1_1container_1_1non__owning__identifier__without__container.html">non_owning_identifier_without_container</a>&gt; <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::m_indices {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointers to identifiers that record the current physical row. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01598">1598</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a83ce8fb5d0c22664284f404f4e6c0fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ce8fb5d0c22664284f404f4e6c0fe9">&#9670;&nbsp;</a></span>m_mut</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::m_mut {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex to protect m_frozen_count and m_sorted. </p>
<p>The frozen tokens are used to detect, possibly concurrent, use of incompatible operations, such as sorting while erasing rows. All operations that modify the structure of the container must happen sequentially.</p>
<p>To prevent a different thread from obtaining a frozen token while this thread is modifying structure of the container, this thread should lock <code>m_mut</code>. Likewise, any thread obtaining a frozen token, should acquire a lock on <code>m_mut</code> to ensure that there are no concurrent operations that require sequential access to the container.</p>
<p>By following this pattern the thread knows that the conditions related to sorted-ness and froze-ness of the container are valid for the entire duration of the operation (== member function of this class).</p>
<p>Note, enforcing proper sequencing of operations is left to the calling code. However, this mutex enforces the required thread-safety to be able to detect invalid concurrent access patterns. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01583">1583</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="ada913a061d655afe9ace8c6a8533108d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada913a061d655afe9ace8c6a8533108d">&#9670;&nbsp;</a></span>m_sorted</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::m_sorted {false}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag for <a class="el" href="structneuron_1_1container_1_1soa.html#a54b3da5eeb40d7038f4eac42fc53dd05" title="Create a token guaranteeing the container is in &quot;frozen&quot; state.">issue_frozen_token()</a>, <a class="el" href="structneuron_1_1container_1_1soa.html#a908668b49668da296f5ee09974f223f8" title="Tell the container it is no longer sorted.">mark_as_unsorted()</a> and <a class="el" href="structneuron_1_1container_1_1soa.html#a10aee5bc82e78fbfe2932ee36fce57f2" title="Query if the underlying vectors are still &quot;sorted&quot;.">is_sorted()</a>. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01588">1588</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="a296e112ea065749bb886a332261f82c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296e112ea065749bb886a332261f82c0">&#9670;&nbsp;</a></span>m_unsorted_callback</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void()&gt; <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::m_unsorted_callback {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Callback that is invoked when the container becomes unsorted. </p>

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l01614">1614</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<a id="aca9e35b3df6aaca6ef52994b3a71c526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9e35b3df6aaca6ef52994b3a71c526">&#9670;&nbsp;</a></span>tag_index_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Tags&gt; </div>
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="structneuron_1_1container_1_1soa.html">neuron::container::soa</a>&lt; Storage, Tags &gt;::tag_index_v = <a class="el" href="namespaceneuron_1_1container_1_1detail.html#a2df65bd89a575b6662ea6941439b6009">detail::index_of_type_v</a>&lt;Tag, Tags...&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="soa__container_8hpp_source.html#l00818">818</a> of file <a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/home/runner/work/nrn/nrn/src/neuron/container/<a class="el" href="soa__container_8hpp_source.html">soa_container.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath">
  <ul>
    <li class="navelem"><a class="el" href="namespaceneuron.html">neuron</a></li><li class="navelem"><a class="el" href="namespaceneuron_1_1container.html">container</a></li><li class="navelem"><a class="el" href="structneuron_1_1container_1_1soa.html">soa</a></li>
  </ul>
</div>
<hr class="footer"/>
<address class="footer">
    <small>
    </small>
</address>
<!--END !GENERATE_TREEVIEW-->
</body>
</html>
