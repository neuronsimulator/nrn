<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Point Processes and Artificial Cells &mdash; NEURON  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-design.min.css?v=87e54e7c" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/custom.css?v=6933245a" />

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../../_static/design-tabs.js?v=f930bc37"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="NMODL" href="nmodl.html" />
    <link rel="prev" title="StateTransitionEvent" href="../ste.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            NEURON
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Building:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../install/install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../cmake_doc/index.html">CMake Build Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../install/developer.html">Developer Builds</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../videos/index.html">Training videos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../guide/index.html">Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../courses/exercises2018.html">NEURON Course Exercises</a></li>
<li class="toctree-l1"><a class="reference external" href="https://neuron.yale.edu/phpBB">The NEURON forum</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../publications.html">Publications about NEURON</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../publications-using-neuron.html">Publications using NEURON</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">NEURON scripting:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../../scripting.html">Running Python and HOC scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../python/index.html">NEURON Python documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../../index.html">NEURON HOC documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../../index.html#quick-links">Quick Links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../index.html#basic-programming">Basic Programming</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../../index.html#model-specification">Model Specification</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../guitools.html">Model Specification GUI Tools</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../../programmatic.html">Programmatic Model Specification</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="../topology.html">Topology</a></li>
<li class="toctree-l4"><a class="reference internal" href="../ions.html">Ions</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="../mechanisms.html">Dynamics (Channels, etc…)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../rxd.html">Basic Reaction-Diffusion</a></li>
<li class="toctree-l4"><a class="reference internal" href="../network.html">Networks</a></li>
<li class="toctree-l4"><a class="reference internal" href="../electrod.html">Electrode</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mechtype.html">MechanismType</a></li>
<li class="toctree-l4"><a class="reference internal" href="../obsoletestimuli.html">Obsolete Stimuli</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../index.html#simulation-control">Simulation Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../index.html#visualization">Visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../index.html#analysis">Analysis</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../otherscripting.html">Other scripting languages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/index.html">Python tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rxd-tutorials/index.html">Python RXD tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../coreneuron/index.html">CoreNEURON</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">NMODLanguage:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../nmodl/index.html">NMODLanguage</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../scm/index.html">NEURON SCM and Release</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../dev/index.html">NEURON Development topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doxygen.html">C/C++ API</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Removed Features</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../removed_features.html">Removed Features</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Changelog</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../changelog.html">NEURON 8.2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../changelog.html#neuron-8-1">NEURON 8.1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../changelog.html#neuron-8-0">NEURON 8.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../changelog.html#contributors">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../changelog.html#feedback-help">Feedback / Help</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">NEURON</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">NEURON HOC documentation</a></li>
          <li class="breadcrumb-item"><a href="../../programmatic.html">Programmatic Model Specification</a></li>
          <li class="breadcrumb-item"><a href="../mechanisms.html">Dynamics (Channels, etc…)</a></li>
      <li class="breadcrumb-item active">Point Processes and Artificial Cells</li>
<li class="wy-breadcrumbs-aside">
    
    
        
        <a href="../../../../..html/../python/modelspec/programmatic/mechanisms/mech.html" > Switch to Python</a>
    
</li>

      <li class="wy-breadcrumbs-aside">
            <a href="../../../../_sources/hoc/modelspec/programmatic/mechanisms/mech.rst.txt" rel="nofollow"> View page source</a>
      </li>

  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p><dl class="docutils"><dt><a href="#AlphaSynapse" title="Link to this definition">AlphaSynapse</a></dt><dd></dd></dl></p><p><dl class="docutils"><dt><a href="#APCount" title="Link to this definition">APCount</a></dt><dd></dd></dl></p><p><dl class="docutils"><dt><a href="#Exp2Syn" title="Link to this definition">Exp2Syn</a></dt><dd></dd></dl></p><p><dl class="docutils"><dt><a href="#ExpSyn" title="Link to this definition">ExpSyn</a></dt><dd></dd></dl></p><p><dl class="docutils"><dt><a href="#IClamp" title="Link to this definition">IClamp</a></dt><dd></dd></dl></p><p><dl class="docutils"><dt><a href="#IntFire1" title="Link to this definition">IntFire1</a></dt><dd></dd></dl></p><p><dl class="docutils"><dt><a href="#IntFire2" title="Link to this definition">IntFire2</a></dt><dd></dd></dl></p><p><dl class="docutils"><dt><a href="#IntFire4" title="Link to this definition">IntFire4</a></dt><dd></dd></dl></p><p><dl class="docutils"><dt><a href="#NetStim" title="Link to this definition">NetStim</a></dt><dd></dd></dl></p><p><dl class="docutils"><dt><a href="#pnt" title="Link to this definition">pnt</a></dt><dd><a href="#pnt.get_loc" title="Link to this definition">get_loc</a> &middot; <a href="#pnt.get_segment" title="Link to this definition">get_segment</a> &middot; <a href="#pnt.has_loc" title="Link to this definition">has_loc</a> &middot; <a href="#pnt.loc" title="Link to this definition">loc</a></dd></dl></p><p><dl class="docutils"><dt><a href="#SEClamp" title="Link to this definition">SEClamp</a></dt><dd></dd></dl></p><p><dl class="docutils"><dt><a href="#VClamp" title="Link to this definition">VClamp</a></dt><dd></dd></dl></p><section id="point-processes-and-artificial-cells">
<span id="hoc-mech"></span><h1>Point Processes and Artificial Cells<a class="headerlink" href="#point-processes-and-artificial-cells" title="Link to this heading"></a></h1>
<dl class="simple">
<dt>Description:</dt><dd><p>Built-in POINT_PROCESS models and ARTIFICIAL_CELL models are listed on the left.
The user may add other classes of those types using mod files. Some properties
and functions that are available for all POINT_PROCESS models are described
under <a class="reference internal" href="#hoc-pointprocesses-general"><span class="std std-ref">General</span></a>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../guitools/pointman.html#hoc-pointprocessmanager"><span class="std std-ref">PointProcessManager</span></a></p>
</div>
<section id="general">
<span id="hoc-pointprocesses-general"></span><h2>General<a class="headerlink" href="#general" title="Link to this heading"></a></h2>
<dl class="hoc method">
<dt class="sig sig-object hoc" id="pnt.get_loc">
<span class="sig-prename descclassname"><span class="pre">pnt.</span></span><span class="sig-name descname"><span class="pre">get_loc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pnt.get_loc" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">pnt.get_loc()</span> <span class="pre">stmt</span> <span class="pre">pop_section()}</span></code></p>
</dd>
<dt>Description:</dt><dd><p>get_loc() pushes the section containing the POINT_PROCESS instance, pnt,
onto the section stack (makes it the currently accessed section), and
returns the position (ranging from 0 to 1) of the POINT_PROCESS instance.
The section stack should be popped when the section is no longer needed.
Note that the braces are necessary if the statement is typed at the top
level since the section stack is automatically popped when waiting for
user input.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../topology/secspec.html#pop_section" title="pop_section"><code class="xref hoc hoc-func docutils literal notranslate"><span class="pre">pop_section()</span></code></a>,
<a class="reference internal" href="#pnt.get_segment" title="pnt.get_segment"><code class="xref hoc hoc-meth docutils literal notranslate"><span class="pre">get_segment()</span></code></a></p>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="hoc method">
<dt class="sig sig-object hoc" id="pnt.get_segment">
<span class="sig-prename descclassname"><span class="pre">pnt.</span></span><span class="sig-name descname"><span class="pre">get_segment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pnt.get_segment" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">pyseg</span> <span class="pre">=</span> <span class="pre">pnt.get_segment()</span></code></p>
</dd>
<dt>Description:</dt><dd><p>A more pythonic version of <a class="reference internal" href="#pnt.get_loc" title="pnt.get_loc"><code class="xref hoc hoc-func docutils literal notranslate"><span class="pre">get_loc()</span></code></a> in that it returns a python segment object
without pushing the section stack. From a segment object one can get the
section with <code class="docutils literal notranslate"><span class="pre">pyseg.sec</span></code> and the position with <code class="docutils literal notranslate"><span class="pre">pyseg.x</span></code>. If the
point process is not located anywhere, the return value is None.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Segment objects become invalid if nseg changes. Discard them as soon as
possible and do not keep them around.</p>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="hoc method">
<dt class="sig sig-object hoc" id="pnt.loc">
<span class="sig-prename descclassname"><span class="pre">pnt.</span></span><span class="sig-name descname"><span class="pre">loc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pnt.loc" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">pnt.loc(x)</span></code></p>
</dd>
<dt>Description:</dt><dd><p>Moves the POINT_PROCESS instance, pnt, to the center of the segment containing
x of the currently accessed section.</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="hoc method">
<dt class="sig sig-object hoc" id="pnt.has_loc">
<span class="sig-prename descclassname"><span class="pre">pnt.</span></span><span class="sig-name descname"><span class="pre">has_loc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pnt.has_loc" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">pnt.has_loc()</span></code></p>
</dd>
<dt>Description:</dt><dd><p>Returns 1 if the POINT_PROCESS instance, pnt, is located in some section,
otherwise, 0.</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="hoc class">
<dt class="sig sig-object hoc" id="IClamp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">IClamp</span></span><a class="headerlink" href="#IClamp" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">stimobj</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">IClamp(x)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">--</span> <span class="pre">ms</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">dur</span> <span class="pre">--</span> <span class="pre">ms</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">amp</span> <span class="pre">--</span> <span class="pre">nA</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">--</span> <span class="pre">nA</span></code></p>
</dd>
<dt>Description:</dt><dd><p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/stim.mod">&lt;nrn src dir&gt;/src/nrnoc/stim.mod</a></p>
<p>Single pulse current clamp point process. This is an electrode current
so positive amp depolarizes the cell. i is set to amp when t is within
the closed interval del to del+dur. Time varying current stimuli can
be simulated by setting del=0, dur=1e9 and playing a vector into amp
with the <a class="reference internal" href="../../../programming/math/vector.html#Vector.play" title="Vector.play"><code class="xref hoc hoc-meth docutils literal notranslate"><span class="pre">play()</span></code></a> <a class="reference internal" href="../../../programming/math/vector.html#Vector" title="Vector"><code class="xref hoc hoc-class docutils literal notranslate"><span class="pre">Vector</span></code></a> method.</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="hoc class">
<dt class="sig sig-object hoc" id="AlphaSynapse">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">AlphaSynapse</span></span><a class="headerlink" href="#AlphaSynapse" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">syn</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">AlphaSynapse(x)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.onset</span> <span class="pre">---</span> <span class="pre">ms</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.tau</span> <span class="pre">---</span> <span class="pre">ms</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.gmax</span> <span class="pre">---</span> <span class="pre">umho</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.e</span> <span class="pre">---</span> <span class="pre">mV</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.i</span> <span class="pre">---</span> <span class="pre">nA</span></code></p>
</dd>
<dt>Description:</dt><dd><p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/syn.mod">&lt;nrn src dir&gt;/src/nrnoc/syn.mod</a>. The comment in this file reads:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>synaptic current with alpha function conductance defined by
        i = g * (v - e)      i(nanoamps), g(micromhos);
        where
         g = 0 for t &lt; onset and
         g = gmax * (t - onset)/tau * exp(-(t - onset - tau)/tau)
          for t &gt; onset
this has the property that the maximum value is gmax and occurs at
 t = delay + tau.
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="hoc class">
<dt class="sig sig-object hoc" id="VClamp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">VClamp</span></span><a class="headerlink" href="#VClamp" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">obj</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">VClamp(x)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">dur[3]</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">amp[3]</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">gain,</span> <span class="pre">rstim,</span> <span class="pre">tau1,</span> <span class="pre">tau2</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">i</span></code></p>
</dd>
<dt>Description:</dt><dd><p>Two electrode voltage clamp.</p>
<p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/vclmp.mod">&lt;nrn src dir&gt;/src/nrnoc/vclmp.mod</a>. The comment in this file reads:</p>
<p>Voltage clamp with three levels. Clamp is on at time 0, and off at time
dur[0]+dur[1]+dur[2]. When clamp is off the injected current is 0.
Do not insert several instances of this model at the same location in
order to
make level changes. That is equivalent to independent clamps and they will
have incompatible internal state values.</p>
<p>The control amplifier has the indicated gain and time constant.  The
input amplifier is ideal.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                 tau2
                 gain
                +-|\____rstim____&gt;to cell
-amp --&#39;\/`-------|/
                |
                |----||---
                |___    __|-----/|___from cell
                    `&#39;`&#39;        \|
                    tau1
</pre></div>
</div>
<p>The clamp has a three states which are the voltage input of the gain amplifier,
the voltage output of the gain amplfier, and the voltage output of the
measuring amplifier.
A good initial condition for these voltages are 0, 0, and v respectively.</p>
<p>This model is quite stiff.  For this reason the current is updated
within the solve block before updating the state of the clamp. This
gives the correct value of the current on exit from <a class="reference internal" href="../../../simctrl/programmatic.html#fadvance" title="fadvance"><code class="xref hoc hoc-func docutils literal notranslate"><span class="pre">fadvance()</span></code></a>. If we
didn’t do this and
instead used the values computed in the breakpoint block, it
would look like the clamp current is much larger than it actually is
since it
doesn’t take into account the change in voltage within the timestep, ie
equivalent to an almost infinite capacitance.
Also, because of stiffness, do not use this model except with <a class="reference internal" href="../../../simctrl/programmatic.html#secondorder" title="secondorder"><code class="xref hoc hoc-data docutils literal notranslate"><span class="pre">secondorder</span></code></a>=0.</p>
<p>This model makes use of implementation details of how models are interfaced
to neuron. At some point I will make the translation such that these kinds
of models can be handled straightforwardly.</p>
<p>Note that since this is an electrode current model v refers to the
internal potential which is equivalent to the membrane potential v when
there is no extracellular membrane mechanism present but is v+vext when
one is present.
Also since i is an electrode current,
positive values of i depolarize the cell. (Normally, positive membrane currents
are outward and thus hyperpolarize the cell)</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="hoc class">
<dt class="sig sig-object hoc" id="SEClamp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">SEClamp</span></span><a class="headerlink" href="#SEClamp" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">clampobj</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">SEClamp(0.5)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">dur1</span> <span class="pre">dur2</span> <span class="pre">dur3</span> <span class="pre">--</span> <span class="pre">ms</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">amp1</span> <span class="pre">amp2</span> <span class="pre">amp3</span> <span class="pre">--</span> <span class="pre">mV</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">rs</span> <span class="pre">--</span> <span class="pre">MOhm</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">vc</span> <span class="pre">--</span> <span class="pre">mV</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">--</span> <span class="pre">nA</span></code></p>
</dd>
<dt>Description:</dt><dd><p>Single electrode voltage clamp with three levels.</p>
<p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/svclmp.mod">&lt;nrn src dir&gt;/src/nrnoc/svclmp.mod</a>. The comment in this file reads:</p>
<p>Single electrode Voltage clamp with three levels.
Clamp is on at time 0, and off at time
dur1+dur2+dur3. When clamp is off the injected current is 0.
The clamp levels are amp1, amp2, amp3.
i is the injected current, vc measures the control voltage)
Do not insert several instances of this model at the same location in
order to
make level changes. That is equivalent to independent clamps and they will
have incompatible internal state values.
The electrical circuit for the clamp is exceedingly simple:</p>
<img alt="../../../../_images/svclmp1.png" class="align-center" src="../../../../_images/svclmp1.png" />
<p>Note that since this is an electrode current model v refers to the
internal potential which is equivalent to the membrane potential v when
there is no extracellular membrane mechanism present but is v+vext when
one is present.
Also since i is an electrode current,
positive values of i depolarize the cell. (Normally, positive membrane currents
are outward and thus hyperpolarize the cell)</p>
<p>This model is careful to ensure the clamp current is properly computed
relative to the membrane voltage on exit from fadvance and can therefore
be used with time varying control potentials. Like <a class="reference internal" href="#VClamp" title="VClamp"><code class="xref hoc hoc-class docutils literal notranslate"><span class="pre">VClamp</span></code></a> it is suitable
for <a class="reference internal" href="../../../programming/math/vector.html#Vector.play" title="Vector.play"><code class="xref hoc hoc-meth docutils literal notranslate"><span class="pre">play()</span></code></a>ing a Vector into the control potential.</p>
<p>The following example compares the current that results from
clamping an action potential originally elicited by a current pulse.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// setup for three simulations
create s1, s2, s3 // will be stimulated by IClamp, SEClamp, and VClamp
forall {insert hh diam=3 L=3 }
objref c1, c2, c3, ap, apc
s1 c1 = new IClamp(0.5)
s2 c2 = new SEClamp(0.5)
s3 c3 = new VClamp(0.5)
{c1.dur=.1 c1.amp=0.3}
{c2.dur1 = 1 c2.rs=0.01 }
{c3.dur[0] = 1}

// record an action potential
ap = new Vector()
ap.record(&amp;s1.v(0.5))
finitialize(-65)
while(t&lt;1) { fadvance() }

// do the three cases while playing the recorded ap
apc = ap.c  // unfortunately can&#39;t play into two variables so clone it.
ap.play_remove()
ap.play(&amp;c2.amp1, dt)
apc.play(&amp;c3.amp[0], dt)
finitialize(-65)
while(t&lt;0.4) {
        fadvance()
        print s1.v, s2.v, s3.v, c1.i, c2.i, c3.i
}
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="hoc class">
<dt class="sig sig-object hoc" id="APCount">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">APCount</span></span><a class="headerlink" href="#APCount" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">apc</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">APCount(x)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">apc.thresh</span> <span class="pre">---</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">mV</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">apc.n</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">apc.time</span> <span class="pre">---</span> <span class="pre">ms</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">apc.record(vector)</span></code></p>
</dd>
<dt>Description:</dt><dd><p>Counts the number of times the voltage at its location crosses a
threshold voltage in the positive direction. n contains the count
and time contains the time of last crossing.</p>
<p>If a Vector is attached to the apc, then it is resized to 0 when the
INITIAL block is called and the times of threshold crossing are
appended to the Vector. apc.record() will stop recording into the vector.
The apc is not notified if the vector is freed but this can be fixed if
it is convenient to add this feature.</p>
<p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/apcount.mod">&lt;nrn src dir&gt;/src/nrnoc/apcount.mod</a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="hoc class">
<dt class="sig sig-object hoc" id="ExpSyn">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ExpSyn</span></span><a class="headerlink" href="#ExpSyn" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">syn</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">ExpSyn(x)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.tau</span> <span class="pre">---</span> <span class="pre">ms</span> <span class="pre">decay</span> <span class="pre">time</span> <span class="pre">constant</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.e</span> <span class="pre">--</span> <span class="pre">mV</span> <span class="pre">reversal</span> <span class="pre">potential</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.i</span> <span class="pre">--</span> <span class="pre">nA</span> <span class="pre">synaptic</span> <span class="pre">current</span></code></p>
</dd>
<dt>Description:</dt><dd><p>Synapse with discontinuous change in conductance at an event followed
by an exponential decay with time constant tau.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>i = G * (v - e)      i(nanoamps), g(micromhos);
  G = weight * exp(-t/tau)
</pre></div>
</div>
<p>The weight is specified
by the <a class="reference internal" href="../network/netcon.html#NetCon.weight" title="NetCon.weight"><code class="xref hoc hoc-data docutils literal notranslate"><span class="pre">weight</span></code></a> field of a <a class="reference internal" href="../network/netcon.html#NetCon" title="NetCon"><code class="xref hoc hoc-class docutils literal notranslate"><span class="pre">NetCon</span></code></a> object.</p>
<p>This synapse summates.</p>
<p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/expsyn.mod">&lt;nrn src dir&gt;/src/nrnoc/expsyn.mod</a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="hoc class">
<dt class="sig sig-object hoc" id="Exp2Syn">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Exp2Syn</span></span><a class="headerlink" href="#Exp2Syn" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">syn</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">Exp2Syn(x)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.tau1</span> <span class="pre">---</span> <span class="pre">ms</span> <span class="pre">rise</span> <span class="pre">time</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.tau2</span> <span class="pre">---</span> <span class="pre">ms</span> <span class="pre">decay</span> <span class="pre">time</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.e</span> <span class="pre">--</span> <span class="pre">mV</span> <span class="pre">reversal</span> <span class="pre">potential</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.i</span> <span class="pre">--</span> <span class="pre">nA</span> <span class="pre">synaptic</span> <span class="pre">current</span></code></p>
</dd>
<dt>Description:</dt><dd><p>Two state kinetic scheme synapse described by rise time tau1,
and decay time constant tau2. The normalized peak condductance is 1.
Decay time MUST be greater than rise time.</p>
<p>The kinetic scheme</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>A    -&gt;   G   -&gt;   bath
   1/tau1   1/tau2
</pre></div>
</div>
<p>produces
a synaptic current with alpha function like conductance (if tau1/tau2
is appoximately 1)
defined by</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>i = G * (v - e)      i(nanoamps), g(micromhos);
  G = weight * factor * (exp(-t/tau2) - exp(-t/tau1))
</pre></div>
</div>
<p>The weight is specified
by the <a class="reference internal" href="../network/netcon.html#NetCon.weight" title="NetCon.weight"><code class="xref hoc hoc-data docutils literal notranslate"><span class="pre">weight</span></code></a> field of a <a class="reference internal" href="../network/netcon.html#NetCon" title="NetCon"><code class="xref hoc hoc-class docutils literal notranslate"><span class="pre">NetCon</span></code></a> object.
The factor is defined so that the normalized peak is 1.
If tau2 is close to tau1
this has the property that the maximum value is weight and occurs at
t = tau1.</p>
<p>Because the solution is a sum of exponentials, the
coupled equations for the kinetic scheme
can be solved as a pair of independent equations
by the more efficient cnexp method.</p>
<p>This synapse summates.</p>
<p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/exp2syn.mod">&lt;nrn src dir&gt;/src/nrnoc/exp2syn.mod</a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="hoc class">
<dt class="sig sig-object hoc" id="NetStim">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">NetStim</span></span><a class="headerlink" href="#NetStim" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">NetStim(x)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">s.interval</span> <span class="pre">ms</span> <span class="pre">(mean)</span> <span class="pre">time</span> <span class="pre">between</span> <span class="pre">spikes</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">s.number</span> <span class="pre">(average)</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">spikes</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">s.start</span> <span class="pre">ms</span> <span class="pre">(most</span> <span class="pre">likely)</span> <span class="pre">start</span> <span class="pre">time</span> <span class="pre">of</span> <span class="pre">first</span> <span class="pre">spike</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">s.noise</span> <span class="pre">----</span> <span class="pre">range</span> <span class="pre">0</span> <span class="pre">to</span> <span class="pre">1.</span> <span class="pre">Fractional</span> <span class="pre">randomness.</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">deterministic,</span> <span class="pre">1</span> <span class="pre">intervals</span> <span class="pre">have</span> <span class="pre">negexp</span> <span class="pre">distribution.</span></code></p>
</dd>
<dt>Description:</dt><dd><p>Generates a train of presynaptic stimuli. Can serve as the source for
a NetCon. This NetStim can also be
be triggered by an input event. i.e serve as the target of a NetCon.
If the stimulator is in the on=0 state and receives a positive weight
event, then the stimulator changes to the on=1 state and goes through
its burst sequence before changing to the on=0 state. During
that time it ignores any positive weight events. If, in the on=1 state,
the stimulator receives a negative weight event, the stimulator will
change to the off state. In the off state, it will ignore negative weight
events. A change to the on state immediately causes the first spike.</p>
<p>Fractional noise, 0 &lt;= noise &lt;= 1, means that an interval between spikes
consists of a fixed interval of duration (1 - noise)*interval plus a negexp
interval of mean duration noise*interval. Note that the most likely negexp
interval has duration 0.</p>
<p>Since NetStim sends events, the proper idiom for specifying it as a source
for a NetCon is</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>objref ns, nc
nc = new NetStim(0.5)
ns = new NetCon(nc, target...)
</pre></div>
</div>
<p>That is, do not use <code class="docutils literal notranslate"><span class="pre">&amp;nc.y</span></code> as the source for the netcon.</p>
<p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/netstim.mod">&lt;nrn src dir&gt;/src/nrnoc/netstim.mod</a></p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Prior to version 5.2.1 an attempt was made to
make the mean start time (noise &gt; 0)
correspond to the value of start. However since it is not possible to
simulate events occurring at t &lt; 0, these spikes were generated at t=0.
Thus the mean start time was not start and the spikes at t=0 did not
obey negexp statistics. For this reason, beginning with version 5.2.1
the semantics of start are the time of the most likely first spike and the
mean start time is start + noise*interval.</p>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="hoc class">
<dt class="sig sig-object hoc" id="IntFire1">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">IntFire1</span></span><a class="headerlink" href="#IntFire1" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">IntFire1(x)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.tau</span> <span class="pre">---</span> <span class="pre">ms</span> <span class="pre">time</span> <span class="pre">constant</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.refrac</span> <span class="pre">---</span> <span class="pre">ms</span> <span class="pre">refractory</span> <span class="pre">period.</span> <span class="pre">Minimum</span> <span class="pre">time</span> <span class="pre">between</span> <span class="pre">events</span> <span class="pre">is</span> <span class="pre">refrac</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.m</span> <span class="pre">---</span> <span class="pre">state</span> <span class="pre">variable</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.M</span> <span class="pre">---</span> <span class="pre">analytic</span> <span class="pre">value</span> <span class="pre">of</span> <span class="pre">state</span> <span class="pre">at</span> <span class="pre">current</span> <span class="pre">time,</span> <span class="pre">t</span></code></p>
</dd>
<dt>Description:</dt><dd><p>A point process that is equivalent to an entire integrate and fire cell.</p>
<p>An output
spike event is sent to all the NetCon instances which have this pointprocess
instance as their source when m &gt;= 1
If m(t0) = m0 and an input event occurs at t1
then the value of m an infinitesimal time before the t1 event is
exp(-(t1 - t0)/tau). After the input event m(t1) = m(t1) + weight where weight
is the weight of the NetCon event.
Input events are ignored for refrac time after the spike output
event.</p>
<p>During the refractory period,  m = 2.
At the end of the refractory period, m = 0.
During the refractory period, the function M() returns a value of 2
for the first 0.5 ms and -1 for the rest of the period. Otherwise it
returns exp((t-t0)/tau)</p>
<p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/intfire1.mod">&lt;nrn src dir&gt;/src/nrnoc/intfire1.mod</a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="hoc class">
<dt class="sig sig-object hoc" id="IntFire2">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">IntFire2</span></span><a class="headerlink" href="#IntFire2" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">IntFire2(x)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.taum</span> <span class="pre">---</span> <span class="pre">ms</span> <span class="pre">membrane</span> <span class="pre">time</span> <span class="pre">constant</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.taus</span> <span class="pre">--</span> <span class="pre">ms</span> <span class="pre">synaptic</span> <span class="pre">current</span> <span class="pre">time</span> <span class="pre">constant</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.ib</span> <span class="pre">--</span> <span class="pre">constant</span> <span class="pre">current</span> <span class="pre">input</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.m</span> <span class="pre">---</span> <span class="pre">membrane</span> <span class="pre">state</span> <span class="pre">variable</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.M</span> <span class="pre">---</span> <span class="pre">analytic</span> <span class="pre">value</span> <span class="pre">of</span> <span class="pre">state</span> <span class="pre">at</span> <span class="pre">current</span> <span class="pre">time,</span> <span class="pre">t</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.i</span> <span class="pre">---</span> <span class="pre">synaptic</span> <span class="pre">current</span> <span class="pre">state</span> <span class="pre">variable</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.I</span> <span class="pre">---</span> <span class="pre">analytic</span> <span class="pre">value</span> <span class="pre">of</span> <span class="pre">synaptic</span> <span class="pre">current.</span></code></p>
</dd>
<dt>Description:</dt><dd><p>A leaky integrator with time constant taum driven by a total
current that is the sum of
{ a user-settable constant “bias” current }
plus
{ a net synaptic current }.
Net synaptic current decays toward 0 with time constant taus, where
taus &gt; taum (synaptic
current decays slowly compared to the rate at which “membrane potential”
m equilibrates).
When an input event with weight w arrives, the net synaptic current
changes abruptly by
the amount w.</p>
<p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/intfire2.mod">&lt;nrn src dir&gt;/src/nrnoc/intfire2.mod</a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="hoc class">
<dt class="sig sig-object hoc" id="IntFire4">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">IntFire4</span></span><a class="headerlink" href="#IntFire4" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">IntFire4(x)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.taue</span> <span class="pre">---</span> <span class="pre">ms</span> <span class="pre">excitatory</span> <span class="pre">input</span> <span class="pre">time</span> <span class="pre">constant</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.taui1</span> <span class="pre">---</span> <span class="pre">ms</span> <span class="pre">inhibitory</span> <span class="pre">input</span> <span class="pre">rise</span> <span class="pre">time</span> <span class="pre">constant</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.taui2</span> <span class="pre">---</span> <span class="pre">ms</span> <span class="pre">inhibitory</span> <span class="pre">input</span> <span class="pre">fall</span> <span class="pre">time</span> <span class="pre">constant</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.taum</span> <span class="pre">---</span> <span class="pre">membrane</span> <span class="pre">time</span> <span class="pre">constant</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.m</span> <span class="pre">---</span> <span class="pre">membrane</span> <span class="pre">state</span> <span class="pre">variable</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.M</span> <span class="pre">---</span> <span class="pre">analytic</span> <span class="pre">value</span> <span class="pre">of</span> <span class="pre">membrane</span> <span class="pre">state</span> <span class="pre">at</span> <span class="pre">current</span> <span class="pre">time,</span> <span class="pre">t</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.e</span> <span class="pre">---</span> <span class="pre">excitatory</span> <span class="pre">current</span> <span class="pre">state</span> <span class="pre">variable</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.E</span> <span class="pre">---</span> <span class="pre">analytic</span> <span class="pre">value</span> <span class="pre">of</span> <span class="pre">excitation</span> <span class="pre">current</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.i1</span> <span class="pre">c.i2</span> <span class="pre">--</span> <span class="pre">inhibitory</span> <span class="pre">current</span> <span class="pre">state</span> <span class="pre">variables</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.I</span> <span class="pre">---</span> <span class="pre">analytic</span> <span class="pre">value</span> <span class="pre">of</span> <span class="pre">inhibitory</span> <span class="pre">current.</span></code></p>
</dd>
<dt>Description:</dt><dd><p>The IntFire4 artificial cell treats excitatory input (positive weight)
events as a sudden change in
current which decays exponentially with time constant taue. Inhibitory
input (negative weight)
events are treated as an alpha function like change to the current. More
precisely the current due
to a negative weight event is the difference between two exponentials
with time constants taui1
and taui2. In the limit as taui2 approaches taui1 then the current due
to the event approaches the
alpha function. The current due to the input events is integrated with a
membrane time constant
of taum. At present there is a constraint taue &lt; taui1 &lt; taui2 &lt; taum
but this may become
relaxed to taue, taui1 &lt; taui2, taum. When the membrane potential
reaches 1, the cell fires and
the membrane potential is re-initialized to 0 and starts integrating
according to the analytic
value of the current (which does NOT depend on firing). Excitatory
events are scaled such that
an isolated event of weight 1 will produce a maximum membrane potential
of 1 (threshold) and
an isolated inhibitory event of weight -1 will produce a minimum
membrane potential of -1.</p>
<p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/intfire4.mod">&lt;nrn src dir&gt;/src/nrnoc/intfire4.mod</a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
</section>
</section>
<section id="mechanisms">
<span id="hoc-mech-mechanisms"></span><h1>Mechanisms<a class="headerlink" href="#mechanisms" title="Link to this heading"></a></h1>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../../programming/ockeywor.html#hoc-keyword-insert"><span class="std std-ref">insert</span></a>, <a class="reference internal" href="../../guitools/inserter.html#hoc-inserter"><span class="std std-ref">Inserter</span></a>, <a class="reference internal" href="nmodl.html#hoc-nmodl"><span class="std std-ref">NMODL</span></a></p>
</div>
<hr class="docutils" />
<p id="hoc-mech-sethoc-data"><span id="index-0"></span><strong>setdata</strong></p>
<blockquote>
<div><dl class="simple">
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">sec</span> <span class="pre">setdata_suffix(x)</span></code></p>
</dd>
<dt>Description:</dt><dd><p>If a mechanism function is called that uses RANGE variables, then the
appropriate data needed by the function must first be indicated via a setdata call.
This is unnecessary if the function uses only GLOBAL variables.
The suffix refers to the name of the mechanism. E.g. setdata_hh().</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The THREADSAFE mechanism case is a bit more complicated if the mechanism
anywhere assigns a value to a GLOBAL variable. When the user explicitly
specifies that a mechanism is THREADSAFE, those GLOBAL variables that
anywhere appear on the left hand side of an assignment statement (and there
is no such assignment with the PROTECT prefix)
are actually
thread specific variables.
Hoc access to thread specific global variables is with respect to a static
instance which is shared by
the first thread in which mechanism actually exists.</p>
</div>
</div></blockquote>
<hr class="docutils" />
<p id="hoc-mech-capacitance"><span id="index-1"></span><strong>capacitance</strong></p>
<blockquote>
<div><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">cm</span> <span class="pre">(uF/cm2)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">i_cap</span> <span class="pre">(mA/cm2)</span></code></p>
</dd>
<dt>Description:</dt><dd><p>capacitance is a mechanism that automatically is inserted into every section.
cm is a range variable with a default value of 1.0.
i_cap is a range variable which contains the varying membrane capacitive current
during a simulation. Note that i_cap is most accurate when a variable step
integration method is used.</p>
</dd>
</dl>
</div></blockquote>
<hr class="docutils" />
<p id="hoc-mech-hh"><span id="index-2"></span><strong>hh</strong></p>
<blockquote>
<div><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">insert</span> <span class="pre">hh</span></code></p>
</dd>
<dt>Description:</dt><dd><p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/hh.mod">&lt;nrn src dir&gt;/src/nrnoc/hh.mod</a></p>
<p>Hodgkin-Huxley sodium, potassium, and leakage channels. Range variables
specific to this model are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>gnabar_hh   0.120 mho/cm2   Maximum specific sodium channel conductance
gkbar_hh    0.036 mho/cm2   Maximum potassium channel conductance
gl_hh       0.0003 mho/cm2  Leakage conductance
el_hh       -54.3 mV        Leakage reversal potential
m_hh                        sodium activation state variable
h_hh                        sodium inactivation state variable
n_hh                        potassium activation state variable
ina_hh      mA/cm2          sodium current through the hh channels
ik_hh       mA/cm2          potassium current through the hh channels

rates_hh(v) computes the global variables [mhn]inf_hh and [mhn]tau_hh
from the rate functions. usetable_hh defaults to 1.
</pre></div>
</div>
<p>This model used the na and k ions to read ena, ek and write ina, ik.</p>
</dd>
</dl>
</div></blockquote>
<hr class="docutils" />
<p id="hoc-mech-pas"><span id="index-3"></span><strong>pas</strong></p>
<blockquote>
<div><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">insert</span> <span class="pre">pas</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">g_pas</span> <span class="pre">--</span> <span class="pre">mho/cm2</span>&#160;&#160;&#160;&#160;&#160; <span class="pre">conductance</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">e_pas</span> <span class="pre">--</span> <span class="pre">mV</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">reversal</span> <span class="pre">potential</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">--</span> <span class="pre">mA/cm2</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">non-specific</span> <span class="pre">current</span></code></p>
</dd>
<dt>Description:</dt><dd><p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/passive.mod">&lt;nrn src dir&gt;/src/nrnoc/passive.mod</a></p>
<p>Passive membrane channel.</p>
</dd>
</dl>
</div></blockquote>
<hr class="docutils" />
<p id="hoc-mech-fastpas"><span id="index-4"></span><strong>fastpas</strong></p>
<blockquote>
<div><p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/passive0.cpp">&lt;nrn src dir&gt;/src/nrnoc/passive0.cpp</a></p>
<p>Passive membrane channel. Same as the <a class="reference internal" href="#hoc-mech-pas"><span class="std std-ref">pas</span></a> mechanism but hand coded to
be a bit faster (avoids the wasteful numerical derivative computation of
the conductance and does not save the current). Generally not worth
using since passive channel computations are not usually the rate limiting
step of a simulation.</p>
</div></blockquote>
<hr class="docutils" />
<p id="hoc-mech-extracellular"><span id="index-5"></span><strong>extracellular</strong></p>
<blockquote>
<div><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">insert</span> <span class="pre">extracellular</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">vext[2]</span> <span class="pre">--</span> <span class="pre">mV</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">i_membrane</span> <span class="pre">--</span> <span class="pre">mA/cm2</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">xraxial[2]</span> <span class="pre">--</span> <span class="pre">MOhms/cm</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">xg[2]</span> <span class="pre">--</span> <span class="pre">mho/cm2</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">xc[2]</span> <span class="pre">--</span> <span class="pre">uF/cm2</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">e_extracellular</span> <span class="pre">--</span> <span class="pre">mV</span></code></p>
</dd>
<dt>Description:</dt><dd><p>Adds two layers of extracellular field to the section. Vext is
solved simultaneously with the v. When the extracellular mechanism
is present, v refers to the membrane potential and vext (i.e. vext[0])
refers to
the extracellular potential just next to the membrane. Thus the
internal potential is v+vext (but see BUGS).</p>
<p>This mechanism is useful for simulating the stimulation with
extracellular electrodes, response in the presence of an extracellular
potential boundary condition computed by some external program, leaky
patch clamps, incomplete seals in the myelin sheath along with current
flow in the space between the myelin and the axon. It is required
when connecting <a class="reference internal" href="../linmod.html#LinearMechanism" title="LinearMechanism"><code class="xref hoc hoc-class docutils literal notranslate"><span class="pre">LinearMechanism</span></code></a> (e.g. a circuit built with
the <span class="menuselection">NEURON Main Menu ‣ Build ‣ Linear Circuit</span>) to extracellular nodes.</p>
<p>i_membrane correctly does not include contributions from ELECTRODE_CURRENT
point processes.</p>
<p>See i_membrane_ at <a class="reference internal" href="../../../simctrl/cvode.html#CVode.use_fast_imem" title="CVode.use_fast_imem"><code class="xref hoc hoc-meth docutils literal notranslate"><span class="pre">CVode.use_fast_imem()</span></code></a>.</p>
<p>The figure illustrates the form the electrical equivalent circuit
when this mechanism is present. Note that previous documentation
was incorrect in showing that e_extracellular was in series with
the <code class="docutils literal notranslate"><span class="pre">xg[nlayer-1],xc[nlayer-1]</span></code> parallel combination.
In fact it has always been the case
that e_extracellular was in series with xg[nlayer-1] and xc[nlayer-1]
was in parallel
with that series combination.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The only reason the standard
distribution is built with nlayer=2 is so that when only a single
layer is needed (the usual case), then e_extracellular is consistent
with the previous documentation with the old default nlayer=1.</p>
</div>
<p>e_extracellular is connected in series with the conductance of
the last extracellular layer.
With two layers the equivalent circuit looks like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>          Ra
o/`--o--&#39;\/\/`--o--&#39;\/\/`--o--&#39;\/\/`--o--&#39;\o vext + v
     |          |          |          |
    ---        ---        ---        ---
   |   |      |   |      |   |      |   |
    ---        ---        ---        ---
     |          |          |          |
     |          |          |          |     i_membrane
     |  xraxial |          |          |
 /`--o--&#39;\/\/`--o--&#39;\/\/`--o--&#39;\/\/`--o--&#39;vext
     |          |          |          |
    ---        ---        ---        ---     xc and xg
   |   |      |   |      |   |      |   |    in  parallel
    ---        ---        ---        ---
     |          |          |          |
     |          |          |          |
     |xraxial[1]|          |          |
 /`--o--&#39;\/\/`--o--&#39;\/\/`--o--&#39;\/\/`--o--&#39;vext[1]
     |          |          |          |
    ---        ---        ---        ---     the series xg[1], e_extracellular
   |   |      |   |      |   |      |   |    combination is in parallel with
   |  ---     |  ---     |  ---     |  ---   the xc[1] capacitance. This is
   |   -      |   -      |   -      |   -    identical to a membrane with
    ---        ---        ---        ---     cm, g_pas, e_pas
     |          |          |          |
-------------------------------------------- ground
</pre></div>
</div>
<p>Extracellular potentials do a great deal
of violence to one’s intuition and it is important that the user
carefully consider the results of simulations that use them.
It is best to start out believing that there are bugs in the method
and attempt to prove their existence.</p>
<p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/extcell.cpp">&lt;nrn src dir&gt;/src/nrnoc/extcell.cpp</a>
and <a class="reference external" href="https://github.com/neuronsimulator/nrn/tree/master/share/examples/nrniv/nrnoc">&lt;nrn src dir&gt;/share/examples/nrniv/nrnoc/extcab*.hoc</a>.</p>
<p>NEURON can be compiled with any number of extracellular layers.
See below.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>xcaxial is also defined but is not implemented. If you need those
then add them with the <a class="reference internal" href="../linmod.html#LinearMechanism" title="LinearMechanism"><code class="xref hoc hoc-class docutils literal notranslate"><span class="pre">LinearMechanism</span></code></a> .</p>
<p>Prior versions of this document indicated that
e_extracellular is in series with the parallel (xc,xg)
pair. In fact it was in series with xg of the layer.
The above equivalent circuit has been changed to reflect the truth
about the implementation.</p>
<p>In v4.3.1 2000/09/06 and before
vext(0) and vext(1) are the voltages at the centers of the first and
last segments instead of the zero area nodes.</p>
<p>Now the above bug is fixed and
vext(0) and vext(1) are the voltages at the zero area nodes.</p>
<p>From extcell.c the comment is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        i_membrane = sav_g * ndlist[i]-&gt;v + sav_rhs;
#if 1
        /* i_membrane is a current density (mA/cm2). However
           it contains contributions from Non-ELECTRODE_CURRENT
           point processes. i_membrane(0) and i_membrane(1) will
           return the membrane current density at the points
           0.5/nseg and 1-0.5/nseg respectively. This can cause
           confusion if non-ELECTRODE_CURRENT point processes
           are located at these 0-area nodes since 1) not only
           is the true current density infinite, but 2) the
           correct absolute current is being computed here
             at the x=1 point but is not available, and 3) the
           correct absolute current at x=0 is not computed
           if the parent is a rootnode or there is no
           extracellular mechanism for the parent of this
           section. Thus, if non-ELECTRODE_CURRENT point processes
           eg synapses, are being used it is not a good idea to
           insert them at the points x=0 or x=1
        */
#else
           i_membrane *= ndlist[i]-&gt;area;
           /* i_membrane is nA for every segment. This is different
              from all other continuous mechanism currents and
              same as PointProcess currents since it contains
              non-ELECTRODE_CURRENT point processes and may
              be non-zero for the zero area nodes.
           */
#endif
</pre></div>
</div>
<p>In v4.3.1 2000/09/06 and before
extracellular layers will not be connected across sections unless
the parent section of the connection contains the extracellular
mechanism. This is because the 0 area node of the connection is
“owned” by the parent section. In particular, root nodes never contain
extracellular mechanisms and thus multiple sections connected to the
root node always appear to be extracellularly disconnected.
This bug has been fixed. However it is still the case that
vext(0) can be non-zero only if the section owning the 0 node has had
the extracellular mechanism inserted. It is best to have every section
in a cell contain the extracellular mechanism if any one of them does
to avoid confusion with regard to (the in fact correct) boundary conditions.</p>
</div>
<dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">nrn/src/nrnoc/options.h</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">#define</span> <span class="pre">EXTRACELLULAR</span> <span class="pre">2</span> <span class="pre">/*</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">extracellular</span> <span class="pre">layers</span> <span class="pre">*/</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">insert</span> <span class="pre">extracellular</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">vext[i]</span> <span class="pre">--</span> <span class="pre">mV</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">i_membrane</span> <span class="pre">--</span> <span class="pre">mA/cm2</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">xraxial[i]</span> <span class="pre">--</span> <span class="pre">MOhms/cm</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">xg[i]</span> <span class="pre">--</span> <span class="pre">mho/cm2</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">xc[i]</span> <span class="pre">--</span> <span class="pre">uF/cm2</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">e_extracellular</span> <span class="pre">--</span> <span class="pre">mV</span></code></p>
</dd>
<dt>Description:</dt><dd><p>If other than 2 extracellular layers is desired, you may recompile the
program by changing the <code class="file docutils literal notranslate"><span class="pre">nrn/src/nrnoc/options.h</span></code> line
<code class="docutils literal notranslate"><span class="pre">#define</span> <span class="pre">EXTRACELLULAR</span> <span class="pre">2</span></code>
to the number of layers desired. Be sure to recompile both nrnoc and nrniv
as well as any user defined .mod files that use the ELECTRODE_CURRENT statement.</p>
<p>Note that vext is a synonym in hoc for vext[0]. Since the default value for
xg[i] = 1e9 all layers start out tightly connected to ground so
previous single layer extracellular simulations should produce the same
results if either xc or e_extracellular was 0.</p>
<p>e_extracellular is connected in series with the conductance of
the last extracellular layer.</p>
</dd>
</dl>
</div></blockquote>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../ste.html" class="btn btn-neutral float-left" title="StateTransitionEvent" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="nmodl.html" class="btn btn-neutral float-right" title="NMODL" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Duke, Yale and the Blue Brain Project.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>