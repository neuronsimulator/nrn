<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Point Processes and Artificial Cells &mdash; NEURON  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-design.min.css?v=87e54e7c" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/custom.css?v=6933245a" />

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../../_static/design-tabs.js?v=f930bc37"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="NMODL" href="nmodl.html" />
    <link rel="prev" title="LinearMechanism" href="../linmod.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            NEURON
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Building:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../install/install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../cmake_doc/index.html">CMake Build Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../install/developer.html">Developer Builds</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../videos/index.html">Training videos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../guide/index.html">Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../courses/exercises2018.html">NEURON Course Exercises</a></li>
<li class="toctree-l1"><a class="reference external" href="https://neuron.yale.edu/phpBB">The NEURON forum</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../publications.html">Publications about NEURON</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../publications-using-neuron.html">Publications using NEURON</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">NEURON scripting:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../../scripting.html">Running Python and HOC scripts</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../../index.html">NEURON Python documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../../index.html#quick-links">Quick Links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../index.html#basic-programming">Basic Programming</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../../index.html#model-specification">Model Specification</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../guitools.html">Model Specification GUI Tools</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../../programmatic.html">Programmatic Model Specification</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="../topology.html">Topology</a></li>
<li class="toctree-l4"><a class="reference internal" href="../ions.html">Ions</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="../mechanisms.html">Dynamics (Channels, etc…)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../rxd.html">Basic Reaction-Diffusion</a></li>
<li class="toctree-l4"><a class="reference internal" href="../network.html">Networks</a></li>
<li class="toctree-l4"><a class="reference internal" href="../electrod.html">Electrode</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mechtype.html">MechanismType</a></li>
<li class="toctree-l4"><a class="reference internal" href="../ste.html">StateTransitionEvent</a></li>
<li class="toctree-l4"><a class="reference internal" href="../obsoletestimuli.html">Obsolete Stimuli</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../index.html#simulation-control">Simulation Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../index.html#visualization">Visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../index.html#analysis">Analysis</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../hoc/index.html">NEURON HOC documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../otherscripting.html">Other scripting languages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/index.html">Python tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rxd-tutorials/index.html">Python RXD tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../coreneuron/index.html">CoreNEURON</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">NMODLanguage:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../nmodl/index.html">NMODLanguage</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../scm/index.html">NEURON SCM and Release</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../dev/index.html">NEURON Development topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doxygen.html">C/C++ API</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Removed Features</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../removed_features.html">Removed Features</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Changelog</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../changelog.html">NEURON 8.2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../changelog.html#neuron-8-1">NEURON 8.1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../changelog.html#neuron-8-0">NEURON 8.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../changelog.html#contributors">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../changelog.html#feedback-help">Feedback / Help</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">NEURON</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">NEURON Python documentation</a></li>
          <li class="breadcrumb-item"><a href="../../programmatic.html">Programmatic Model Specification</a></li>
          <li class="breadcrumb-item"><a href="../mechanisms.html">Dynamics (Channels, etc…)</a></li>
      <li class="breadcrumb-item active">Point Processes and Artificial Cells</li>
<li class="wy-breadcrumbs-aside">
    
    
        
        <a href="../../../../..html/../hoc/modelspec/programmatic/mechanisms/mech.html" >  Switch to HOC</a>
    
</li>

      <li class="wy-breadcrumbs-aside">
            <a href="../../../../_sources/python/modelspec/programmatic/mechanisms/mech.rst.txt" rel="nofollow"> View page source</a>
      </li>

  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p><dl class="docutils"><dt><a href="#AlphaSynapse" title="Link to this definition">AlphaSynapse</a></dt><dd></dd></dl></p><p><dl class="docutils"><dt><a href="#APCount" title="Link to this definition">APCount</a></dt><dd></dd></dl></p><p><dl class="docutils"><dt><a href="#Exp2Syn" title="Link to this definition">Exp2Syn</a></dt><dd></dd></dl></p><p><dl class="docutils"><dt><a href="#ExpSyn" title="Link to this definition">ExpSyn</a></dt><dd></dd></dl></p><p><dl class="docutils"><dt><a href="#IClamp" title="Link to this definition">IClamp</a></dt><dd></dd></dl></p><p><dl class="docutils"><dt><a href="#IntFire1" title="Link to this definition">IntFire1</a></dt><dd></dd></dl></p><p><dl class="docutils"><dt><a href="#IntFire2" title="Link to this definition">IntFire2</a></dt><dd></dd></dl></p><p><dl class="docutils"><dt><a href="#IntFire4" title="Link to this definition">IntFire4</a></dt><dd></dd></dl></p><p><dl class="docutils"><dt><a href="#NetStim" title="Link to this definition">NetStim</a></dt><dd></dd></dl></p><p><dl class="docutils"><dt><a href="#PatternStim" title="Link to this definition">PatternStim</a></dt><dd></dd></dl></p><p><dl class="docutils"><dt><a href="#pnt" title="Link to this definition">pnt</a></dt><dd><a href="#pnt.get_loc" title="Link to this definition">get_loc</a> &middot; <a href="#pnt.get_segment" title="Link to this definition">get_segment</a> &middot; <a href="#pnt.has_loc" title="Link to this definition">has_loc</a> &middot; <a href="#pnt.loc" title="Link to this definition">loc</a></dd></dl></p><p><dl class="docutils"><dt><a href="#SEClamp" title="Link to this definition">SEClamp</a></dt><dd></dd></dl></p><p><dl class="docutils"><dt><a href="#VClamp" title="Link to this definition">VClamp</a></dt><dd></dd></dl></p><section id="point-processes-and-artificial-cells">
<span id="mech"></span><h1>Point Processes and Artificial Cells<a class="headerlink" href="#point-processes-and-artificial-cells" title="Link to this heading"></a></h1>
<dl class="simple">
<dt>Description:</dt><dd><p>Built-in POINT_PROCESS models and ARTIFICIAL_CELL models are listed above.
The user may add other classes of those types using mod files. Some properties
and functions that are available for all POINT_PROCESS models are described
under <a class="reference internal" href="#pointprocesses-general"><span class="std std-ref">General</span></a>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../../../../hoc/modelspec/guitools/pointman.html#pointprocessmanager"><span class="std std-ref">PointProcessManager</span></a></p>
</div>
<section id="general">
<span id="pointprocesses-general"></span><h2>General<a class="headerlink" href="#general" title="Link to this heading"></a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="pnt.get_loc">
<span class="sig-prename descclassname"><span class="pre">pnt.</span></span><span class="sig-name descname"><span class="pre">get_loc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pnt.get_loc" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">pnt</span><span class="o">.</span><span class="n">get_loc</span><span class="p">()</span>
<span class="n">sec</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">cas</span><span class="p">()</span>
<span class="n">h</span><span class="o">.</span><span class="n">pop_section</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt>Description:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">pnt.get_loc()</span></code> pushes the section containing the POINT_PROCESS instance, pnt,
onto the section stack (makes it the currently accessed section, readable via <code class="docutils literal notranslate"><span class="pre">h.cas()</span></code>), and
returns the position (ranging from 0 to 1) of the POINT_PROCESS instance.
The section stack should be popped when the section is no longer needed.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../topology/secspec.html#pop_section" title="pop_section"><code class="xref py py-func docutils literal notranslate"><span class="pre">pop_section()</span></code></a>,
<a class="reference internal" href="#pnt.get_segment" title="pnt.get_segment"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_segment()</span></code></a></p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Due to the manipulation of NEURON’s section stack, this function is best
avoided in new Python code; use <a class="reference internal" href="#pnt.get_segment" title="pnt.get_segment"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_segment()</span></code></a> instead.</p>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py method">
<dt class="sig sig-object py" id="pnt.get_segment">
<span class="sig-prename descclassname"><span class="pre">pnt.</span></span><span class="sig-name descname"><span class="pre">get_segment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pnt.get_segment" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">pyseg</span> <span class="pre">=</span> <span class="pre">pnt.get_segment()</span></code></p>
</dd>
<dt>Description:</dt><dd><p>Returns the segment containing the point process.
From a segment object one can get the
section with <code class="docutils literal notranslate"><span class="pre">pyseg.sec</span></code> and the position with <code class="docutils literal notranslate"><span class="pre">pyseg.x</span></code>. If the
point process is not located anywhere, the return value is None.</p>
</dd>
</dl>
<p>Example:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">Section</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ic</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">IClamp</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ic</span><span class="o">.</span><span class="n">get_segment</span><span class="p">()</span>
<span class="go">s(0.5)</span>
</pre></div>
</div>
</div></blockquote>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Segment objects become invalid if nseg changes. Discard them as soon as
possible and do not keep them around.</p>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py method">
<dt class="sig sig-object py" id="pnt.loc">
<span class="sig-prename descclassname"><span class="pre">pnt.</span></span><span class="sig-name descname"><span class="pre">loc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pnt.loc" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">pnt.loc(section(x))</span></code></p>
</dd>
<dt>Description:</dt><dd><p>Moves the POINT_PROCESS instance, pnt, to the center of the segment <code class="docutils literal notranslate"><span class="pre">section(x)</span></code>.</p>
<p>The syntax <code class="docutils literal notranslate"><span class="pre">pnt.loc(x,</span> <span class="pre">sec=section)</span></code> will also work.</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="py method">
<dt class="sig sig-object py" id="pnt.has_loc">
<span class="sig-prename descclassname"><span class="pre">pnt.</span></span><span class="sig-name descname"><span class="pre">has_loc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pnt.has_loc" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">pnt.has_loc()</span></code></p>
</dd>
<dt>Description:</dt><dd><p>Returns 1 if the POINT_PROCESS instance, pnt, is located in some section,
otherwise, 0.</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="py class">
<dt class="sig sig-object py" id="IClamp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">IClamp</span></span><a class="headerlink" href="#IClamp" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">stimobj</span> <span class="pre">=</span> <span class="pre">h.IClamp(section(x))</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">delay</span> <span class="pre">--</span> <span class="pre">ms</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">dur</span> <span class="pre">--</span> <span class="pre">ms</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">amp</span> <span class="pre">--</span> <span class="pre">nA</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">--</span> <span class="pre">nA</span></code></p>
</dd>
<dt>Description:</dt><dd><p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/stim.mod">&lt;nrn src dir&gt;/src/nrnoc/stim.mod</a></p>
<p>Single pulse current clamp point process. This is an electrode current
so positive amp depolarizes the cell. i is set to amp when t is within
the closed interval delay to delay+dur. Time varying current stimuli can
be simulated by setting delay=0, dur=1e9 and playing a vector into
_ref_amp  with the <a class="reference internal" href="../../../programming/math/vector.html#Vector.play" title="Vector.play"><code class="xref py py-meth docutils literal notranslate"><span class="pre">play()</span></code></a> <a class="reference internal" href="../../../programming/math/vector.html#Vector" title="Vector"><code class="xref py py-class docutils literal notranslate"><span class="pre">Vector</span></code></a> method.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In HOC, <code class="docutils literal notranslate"><span class="pre">delay</span></code> was known as <code class="docutils literal notranslate"><span class="pre">del</span></code>, but this had to be renamed for Python as <code class="docutils literal notranslate"><span class="pre">del</span></code>
is a Python keyword.</p>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py class">
<dt class="sig sig-object py" id="AlphaSynapse">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">AlphaSynapse</span></span><a class="headerlink" href="#AlphaSynapse" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">syn</span> <span class="pre">=</span> <span class="pre">h.AlphaSynapse(section(x))</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.onset</span> <span class="pre">---</span> <span class="pre">ms</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.tau</span> <span class="pre">---</span> <span class="pre">ms</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.gmax</span> <span class="pre">---</span> <span class="pre">umho</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.e</span> <span class="pre">---</span> <span class="pre">mV</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.i</span> <span class="pre">---</span> <span class="pre">nA</span></code></p>
</dd>
<dt>Description:</dt><dd><p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/syn.mod">&lt;nrn src dir&gt;/src/nrnoc/syn.mod</a>. The comment in this file reads:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>synaptic current with alpha function conductance defined by
        i = g * (v - e)      i(nanoamps), g(micromhos);
        where
         g = 0 for t &lt; onset and
         g = gmax * (t - onset)/tau * exp(-(t - onset - tau)/tau)
          for t &gt; onset
this has the property that the maximum value is gmax and occurs at
 t = delay + tau.
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="py class">
<dt class="sig sig-object py" id="VClamp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">VClamp</span></span><a class="headerlink" href="#VClamp" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">vc</span> <span class="pre">=</span> <span class="pre">h.VClamp(section(x))</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">vc.dur[0]</span></code>, <code class="docutils literal notranslate"><span class="pre">vc.dur[1]</span></code>, <code class="docutils literal notranslate"><span class="pre">vc.dur[2]</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">vc.amp[0]</span></code>, <code class="docutils literal notranslate"><span class="pre">vc.amp[1]</span></code>, <code class="docutils literal notranslate"><span class="pre">vc.amp[2]</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">vc.gain,</span> <span class="pre">vc.rstim,</span> <span class="pre">vc.tau1,</span> <span class="pre">vc.tau2</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">vc.i</span></code></p>
</dd>
<dt>Description:</dt><dd><p>Two electrode voltage clamp.</p>
<p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/vclmp.mod">&lt;nrn src dir&gt;/src/nrnoc/vclmp.mod</a>. The comment in this file reads:</p>
<p>Voltage clamp with three levels. Clamp is on at time 0, and off at time
dur[0]+dur[1]+dur[2]. When clamp is off the injected current is 0.
Do not insert several instances of this model at the same location in
order to
make level changes. That is equivalent to independent clamps and they will
have incompatible internal state values.</p>
<p>The control amplifier has the indicated gain and time constant.  The
input amplifier is ideal.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>                 tau2
                 gain
                +-|\____rstim____&gt;to cell
-amp --&#39;\/`-------|/
                |
                |----||---
                |___    __|-----/|___from cell
                    `&#39;`&#39;        \|
                    tau1
</pre></div>
</div>
<p>The clamp has a three states which are the voltage input of the gain amplifier,
the voltage output of the gain amplfier, and the voltage output of the
measuring amplifier.
A good initial condition for these voltages are 0, 0, and v respectively.</p>
<p>This model is quite stiff.  For this reason the current is updated
within the solve block before updating the state of the clamp. This
gives the correct value of the current on exit from <a class="reference internal" href="../../../simctrl/programmatic.html#fadvance" title="fadvance"><code class="xref py py-func docutils literal notranslate"><span class="pre">fadvance()</span></code></a>. If we
didn’t do this and
instead used the values computed in the breakpoint block, it
would look like the clamp current is much larger than it actually is
since it
doesn’t take into account the change in voltage within the timestep, ie
equivalent to an almost infinite capacitance.
Also, because of stiffness, do not use this model except with <a class="reference internal" href="../../../simctrl/programmatic.html#secondorder" title="secondorder"><code class="xref py py-data docutils literal notranslate"><span class="pre">secondorder</span></code></a>=0.</p>
<p>This model makes use of implementation details of how models are interfaced
to neuron. At some point I will make the translation such that these kinds
of models can be handled straightforwardly.</p>
<p>Note that since this is an electrode current model v refers to the
internal potential which is equivalent to the membrane potential v when
there is no extracellular membrane mechanism present but is v+vext when
one is present.
Also since i is an electrode current,
positive values of i depolarize the cell. (Normally, positive membrane currents
are outward and thus hyperpolarize the cell)</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="py class">
<dt class="sig sig-object py" id="SEClamp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">SEClamp</span></span><a class="headerlink" href="#SEClamp" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">clampobj</span> <span class="pre">=</span> <span class="pre">h.SEClamp(section(x))</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">.dur1</span> <span class="pre">.dur2</span> <span class="pre">.dur3</span> <span class="pre">--</span> <span class="pre">ms</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">.amp1</span> <span class="pre">.amp2</span> <span class="pre">.amp3</span> <span class="pre">--</span> <span class="pre">mV</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">.rs</span> <span class="pre">--</span> <span class="pre">MOhm</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">.vc</span> <span class="pre">--</span> <span class="pre">mV</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">.i</span> <span class="pre">--</span> <span class="pre">nA</span></code></p>
</dd>
<dt>Description:</dt><dd><p>Single electrode voltage clamp with three levels.</p>
<p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/svclmp.mod">&lt;nrn src dir&gt;/src/nrnoc/svclmp.mod</a>. The comment in this file reads:</p>
<p>Single electrode Voltage clamp with three levels.
Clamp is on at time 0, and off at time
dur1+dur2+dur3. When clamp is off the injected current is 0.
The clamp levels are amp1, amp2, amp3.
i is the injected current, vc measures the control voltage)
Do not insert several instances of this model at the same location in
order to
make level changes. That is equivalent to independent clamps and they will
have incompatible internal state values.
The electrical circuit for the clamp is exceedingly simple:</p>
<img alt="../../../../_images/svclmp.png" class="align-center" src="../../../../_images/svclmp.png" />
<p>Note that since this is an electrode current model v refers to the
internal potential which is equivalent to the membrane potential v when
there is no extracellular membrane mechanism present but is v+vext when
one is present.
Also since i is an electrode current,
positive values of i depolarize the cell. (Normally, positive membrane currents
are outward and thus hyperpolarize the cell)</p>
<p>This model is careful to ensure the clamp current is properly computed
relative to the membrane voltage on exit from fadvance and can therefore
be used with time varying control potentials. Like <a class="reference internal" href="#VClamp" title="VClamp"><code class="xref py py-class docutils literal notranslate"><span class="pre">VClamp</span></code></a> it is suitable
for <a class="reference internal" href="../../../programming/math/vector.html#Vector.play" title="Vector.play"><code class="xref py py-meth docutils literal notranslate"><span class="pre">play()</span></code></a>ing a Vector into the control potential.</p>
<p>The following example compares the current that results from
clamping an action potential originally elicited by a current pulse.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">neuron</span> <span class="kn">import</span> <span class="n">h</span>

<span class="c1"># setup for three simulations</span>
<span class="n">s1</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">Section</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;s1&#39;</span><span class="p">)</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">Section</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;s2&#39;</span><span class="p">)</span>
<span class="n">s3</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">Section</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;s3&#39;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="p">[</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">s3</span><span class="p">]:</span>
    <span class="n">sec</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="s1">&#39;hh&#39;</span><span class="p">)</span>   <span class="c1"># equivalently: sec.insert(h.hh)</span>
    <span class="n">sec</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">sec</span><span class="o">.</span><span class="n">diam</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">c1</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">IClamp</span><span class="p">(</span><span class="n">s1</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span>
<span class="n">c2</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">SEClamp</span><span class="p">(</span><span class="n">s2</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span>
<span class="n">c3</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">VClamp</span><span class="p">(</span><span class="n">s3</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span>
<span class="n">c1</span><span class="o">.</span><span class="n">dur</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">c1</span><span class="o">.</span><span class="n">amp</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="n">c2</span><span class="o">.</span><span class="n">dur1</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">c2</span><span class="o">.</span><span class="n">rs</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">c3</span><span class="o">.</span><span class="n">dur</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># record an action potential</span>
<span class="n">ap</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">Vector</span><span class="p">()</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">s1</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">_ref_v</span><span class="p">)</span>
<span class="n">h</span><span class="o">.</span><span class="n">finitialize</span><span class="p">(</span><span class="o">-</span><span class="mi">65</span><span class="p">)</span>
<span class="k">while</span> <span class="n">h</span><span class="o">.</span><span class="n">t</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">h</span><span class="o">.</span><span class="n">fadvance</span><span class="p">()</span>

<span class="c1"># do the three cases while playing the recorder ap</span>
<span class="n">apc</span> <span class="o">=</span> <span class="n">ap</span><span class="o">.</span><span class="n">c</span><span class="p">()</span> <span class="c1"># unfortunately, cannot play into two variables, so clone it</span>
<span class="n">ap</span><span class="o">.</span><span class="n">play_remove</span><span class="p">()</span>
<span class="n">ap</span><span class="o">.</span><span class="n">play</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">_ref_amp1</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
<span class="n">apc</span><span class="o">.</span><span class="n">play</span><span class="p">(</span><span class="n">c3</span><span class="o">.</span><span class="n">_ref_amp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">h</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
<span class="n">h</span><span class="o">.</span><span class="n">finitialize</span><span class="p">(</span><span class="o">-</span><span class="mi">65</span><span class="p">)</span>

<span class="k">while</span> <span class="n">h</span><span class="o">.</span><span class="n">t</span> <span class="o">&lt;</span> <span class="mf">0.4</span><span class="p">:</span>
    <span class="n">h</span><span class="o">.</span><span class="n">fadvance</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%11g</span><span class="s1"> </span><span class="si">%11g</span><span class="s1"> </span><span class="si">%11g</span><span class="s1"> </span><span class="si">%11g</span><span class="s1"> </span><span class="si">%11g</span><span class="s1"> </span><span class="si">%11g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">v</span><span class="p">,</span> <span class="n">s2</span><span class="o">.</span><span class="n">v</span><span class="p">,</span> <span class="n">s3</span><span class="o">.</span><span class="n">v</span><span class="p">,</span> <span class="n">c1</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">c2</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">c3</span><span class="o">.</span><span class="n">i</span><span class="p">))</span>
</pre></div>
</div>
<p>Output:</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>   -38.9151         -65    -64.9987         0.3 -8.57284e-06 6.08992e-06
   -13.2522    -38.9181    -39.9175         0.3    0.299966     0.28846
    12.0382    -13.2552    -14.2775         0.3    0.299999    0.299544
    36.8707     12.0352     11.0258         0.3         0.3    0.299976
    35.8703     36.8677      35.876           0    0.299999    0.299835
    35.9246     35.8703     35.8698           0 3.53006e-05   0.0116979
     36.944     35.9246     35.9218           0 1.88827e-06 0.000592712
    38.5089      36.944     36.9039           0 1.91897e-06 7.48624e-05
    40.1456     38.5089     38.4464           0 1.60753e-06 -2.12119e-05
    41.5259     40.1456     40.0795           0 1.15519e-06 -6.25541e-05
    42.5135     41.5259     41.4695           0 7.13443e-07 -6.92656e-05
    43.1106     42.5135     42.4725           0 3.47428e-07 -5.86879e-05
    43.3834     43.1106     43.0853           0 6.29392e-08 -4.51288e-05
    43.4093     43.3834     43.3711           0 -1.57826e-07 -3.50748e-05
    43.2531     43.4093      43.407           0 -3.34836e-07 -2.94783e-05
    42.9618     43.2531     43.2582           0 -4.82874e-07 -2.71847e-05
</pre></div>
</div>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="py class">
<dt class="sig sig-object py" id="APCount">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">APCount</span></span><a class="headerlink" href="#APCount" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">apc</span> <span class="pre">=</span> <span class="pre">h.APCount(section(x))</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">apc.thresh</span> <span class="pre">---</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">mV</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">apc.n</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">apc.time</span> <span class="pre">---</span> <span class="pre">ms</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">apc.record(vector)</span></code></p>
</dd>
<dt>Description:</dt><dd><p>Counts the number of times the voltage at its location crosses a
threshold voltage in the positive direction. n contains the count
and time contains the time of last crossing.</p>
<p>If a <a class="reference internal" href="../../../programming/math/vector.html#Vector" title="Vector"><code class="xref py py-class docutils literal notranslate"><span class="pre">Vector</span></code></a> is attached to the apc, then it is resized to 0 when the
INITIAL block is called and the times of threshold crossing are
appended to the Vector. apc.record() will stop recording into the vector.
The apc is not notified if the vector is freed but this can be fixed if
it is convenient to add this feature.</p>
<p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/apcount.mod">&lt;nrn src dir&gt;/src/nrnoc/apcount.mod</a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="py class">
<dt class="sig sig-object py" id="ExpSyn">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ExpSyn</span></span><a class="headerlink" href="#ExpSyn" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">syn</span> <span class="pre">=</span> <span class="pre">h.ExpSyn(section(x))</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.tau</span> <span class="pre">---</span> <span class="pre">ms</span> <span class="pre">decay</span> <span class="pre">time</span> <span class="pre">constant</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.e</span> <span class="pre">--</span> <span class="pre">mV</span> <span class="pre">reversal</span> <span class="pre">potential</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.i</span> <span class="pre">--</span> <span class="pre">nA</span> <span class="pre">synaptic</span> <span class="pre">current</span></code></p>
</dd>
<dt>Description:</dt><dd><p>Synapse with discontinuous change in conductance at an event followed
by an exponential decay with time constant tau.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>i = G * (v - e)      i(nanoamps), g(micromhos);
  G = weight * exp(-t/tau)
</pre></div>
</div>
<p>The weight is specified
by the <a class="reference internal" href="../network/netcon.html#NetCon.weight" title="NetCon.weight"><code class="xref py py-data docutils literal notranslate"><span class="pre">weight</span></code></a> field of a <a class="reference internal" href="../network/netcon.html#NetCon" title="NetCon"><code class="xref py py-class docutils literal notranslate"><span class="pre">NetCon</span></code></a> object.</p>
<p>This synapse summates.</p>
<p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/expsyn.mod">&lt;nrn src dir&gt;/src/nrnoc/expsyn.mod</a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="py class">
<dt class="sig sig-object py" id="Exp2Syn">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Exp2Syn</span></span><a class="headerlink" href="#Exp2Syn" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">syn</span> <span class="pre">=</span> <span class="pre">h.Exp2Syn(section(x))</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.tau1</span> <span class="pre">---</span> <span class="pre">ms</span> <span class="pre">rise</span> <span class="pre">time</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.tau2</span> <span class="pre">---</span> <span class="pre">ms</span> <span class="pre">decay</span> <span class="pre">time</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.e</span> <span class="pre">--</span> <span class="pre">mV</span> <span class="pre">reversal</span> <span class="pre">potential</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">syn.i</span> <span class="pre">--</span> <span class="pre">nA</span> <span class="pre">synaptic</span> <span class="pre">current</span></code></p>
</dd>
<dt>Description:</dt><dd><p>Two state kinetic scheme synapse described by rise time tau1,
and decay time constant tau2. The normalized peak condductance is 1.
Decay time MUST be greater than rise time.</p>
<p>The kinetic scheme</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>A    -&gt;   G   -&gt;   bath
   1/tau1   1/tau2
</pre></div>
</div>
<p>produces
a synaptic current with alpha function like conductance (if tau1/tau2
is appoximately 1)
defined by</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>i = G * (v - e)      i(nanoamps), g(micromhos);
  G = weight * factor * (exp(-t/tau2) - exp(-t/tau1))
</pre></div>
</div>
<p>The weight is specified
by the <a class="reference internal" href="../network/netcon.html#NetCon.weight" title="NetCon.weight"><code class="xref py py-data docutils literal notranslate"><span class="pre">weight</span></code></a> field of a <a class="reference internal" href="../network/netcon.html#NetCon" title="NetCon"><code class="xref py py-class docutils literal notranslate"><span class="pre">NetCon</span></code></a> object.
The factor is defined so that the normalized peak is 1.
If tau2 is close to tau1
this has the property that the maximum value is weight and occurs at
t = tau1.</p>
<p>Because the solution is a sum of exponentials, the
coupled equations for the kinetic scheme
can be solved as a pair of independent equations
by the more efficient cnexp method.</p>
<p>This synapse summates.</p>
<p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/exp2syn.mod">&lt;nrn src dir&gt;/src/nrnoc/exp2syn.mod</a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="py class">
<dt class="sig sig-object py" id="NetStim">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">NetStim</span></span><a class="headerlink" href="#NetStim" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">h.NetStim()</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">s.interval</span> <span class="pre">ms</span> <span class="pre">(mean)</span> <span class="pre">time</span> <span class="pre">between</span> <span class="pre">spikes</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">s.number</span> <span class="pre">(average)</span> <span class="pre">number</span> <span class="pre">of</span> <span class="pre">spikes</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">s.start</span> <span class="pre">ms</span> <span class="pre">(most</span> <span class="pre">likely)</span> <span class="pre">start</span> <span class="pre">time</span> <span class="pre">of</span> <span class="pre">first</span> <span class="pre">spike</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">s.noise</span> <span class="pre">----</span> <span class="pre">range</span> <span class="pre">0</span> <span class="pre">to</span> <span class="pre">1.</span> <span class="pre">Fractional</span> <span class="pre">randomness.</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">deterministic,</span> <span class="pre">1</span> <span class="pre">intervals</span> <span class="pre">have</span> <span class="pre">negexp</span> <span class="pre">distribution.</span></code></p>
</dd>
<dt>Description:</dt><dd><p>Generates a train of presynaptic stimuli. Can serve as the source for
a NetCon. This NetStim can also be
be triggered by an input event. i.e serve as the target of a NetCon.
If the stimulator is in the on=0 state and receives a positive weight
event, then the stimulator changes to the on=1 state and goes through
its sequence of ‘nspike’ spikes before changing to the on=0 state. During
that time it ignores any positive weight events. If, in the on=1 state,
the stimulator receives a negative weight event, the stimulator will
change to the off state. In the off state, it will ignore negative weight
events. A change to the on state immediately causes the first spike.</p>
<p>Fractional noise, 0 &lt;= noise &lt;= 1, means that an interval between spikes
consists of a fixed interval of duration (1 - noise)*interval plus a negexp
interval of mean duration noise*interval. Note that the most likely negexp
interval has duration 0.</p>
<p>Since NetStim sends events, the proper idiom for specifying it as a source
for a NetCon is</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">neuron</span> <span class="kn">import</span> <span class="n">h</span>

<span class="n">nc</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">NetStim</span><span class="p">()</span>
<span class="n">ns</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">NetCon</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">target</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>That is, do not use <code class="docutils literal notranslate"><span class="pre">nc._ref_y</span></code> as the source for the netcon.</p>
<p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/netstim.mod">&lt;nrn src dir&gt;/src/nrnoc/netstim.mod</a></p>
</dd>
</dl>
<p>Example:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">neuron</span> <span class="kn">import</span> <span class="n">h</span><span class="p">,</span> <span class="n">gui</span>

<span class="n">ns</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">NetStim</span><span class="p">()</span>
<span class="n">ns</span><span class="o">.</span><span class="n">interval</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">ns</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">ns</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># NetStim starts in OFF state.</span>

<span class="c1">#print spike times coming from ns</span>
<span class="k">def</span> <span class="nf">pr</span><span class="p">():</span>
  <span class="nb">print</span> <span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>
<span class="n">ncout</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">NetCon</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="n">ncout</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">pr</span><span class="p">)</span>

<span class="c1">#another NetStim to cause ns to burst every 20 ms, 3 times, starting at 30ms</span>
<span class="n">ns2</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">NetStim</span><span class="p">()</span>
<span class="n">ns2</span><span class="o">.</span><span class="n">interval</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">ns2</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">ns2</span><span class="o">.</span><span class="n">start</span><span class="o">=</span><span class="mi">30</span>
<span class="n">nctrig</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">NetCon</span><span class="p">(</span><span class="n">ns2</span><span class="p">,</span> <span class="n">ns</span><span class="p">)</span>
<span class="n">nctrig</span><span class="o">.</span><span class="n">delay</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">nctrig</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">h</span><span class="o">.</span><span class="n">tstop</span><span class="o">=</span><span class="mi">500</span>
<span class="n">h</span><span class="o">.</span><span class="n">cvode_active</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">h</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<dl>
<dt>Output:</dt><dd><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>30.1
32.1
34.1
36.1
38.1
50.1
52.1
54.1
56.1
58.1
70.1
72.1
74.1
76.1
78.1
</pre></div>
</div>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Prior to version 5.2.1 an attempt was made to
make the mean start time (noise &gt; 0)
correspond to the value of start. However since it is not possible to
simulate events occurring at t &lt; 0, these spikes were generated at t=0.
Thus the mean start time was not start and the spikes at t=0 did not
obey negexp statistics. For this reason, beginning with version 5.2.1
the semantics of start are the time of the most likely first spike and the
mean start time is start + noise*interval.</p>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py class">
<dt class="sig sig-object py" id="PatternStim">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">PatternStim</span></span><a class="headerlink" href="#PatternStim" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">h.PatternStim()</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">s.play(tvec,</span> <span class="pre">gidvec)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">s.fake_output</span> <span class="pre">---</span> <span class="pre">0</span> <span class="pre">or</span> <span class="pre">1</span></code></p>
</dd>
<dt>Description:</dt><dd><p>The spikeout pairs (t, gid) resulting from a parallel network simulation
can become the stimulus for any single cpu subnet.
Only spikes with gid’s that are not owned by this process and are associated
with NetCon instances created by pc.gid_connect(gid, target) are delivered
when s.fake_output == 0. If s.fake_output == 1, all spikes associated with gid’s
specified by pc.gid_connect(gid, target) including those gid’s owned by this process
are delivered.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>PatternStim.play(tvec, gidvec) makes a copy of the information in
tvec and gidvec so those vectors can be unreferenced so that their
memory is freed.
Calling s.play() with no arguments turns off the PatternStim and frees
its copy of the (t, gid) information.</p>
</div>
<dl>
<dt>Example:</dt><dd><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">neuron</span> <span class="kn">import</span> <span class="n">h</span>
<span class="n">pc</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">ParallelContext</span><span class="p">()</span>

<span class="c1">#Model</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">IntFire1</span><span class="p">()</span>
<span class="n">cell</span><span class="o">.</span><span class="n">refrac</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># no limit on spike rate</span>
<span class="n">pc</span><span class="o">.</span><span class="n">set_gid2node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pc</span><span class="o">.</span><span class="n">id</span><span class="p">())</span>
<span class="n">pc</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">NetCon</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="c1"># generates a spike with gid=0</span>
<span class="n">nclist</span> <span class="o">=</span> <span class="p">[</span><span class="n">pc</span><span class="o">.</span><span class="n">gid_connect</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cell</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span> <span class="c1">#note gid=0 recursive connection</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nclist</span><span class="p">):</span>
  <span class="n">nc</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># anything above 1 causes immediate firing for IntFire1</span>
  <span class="n">nc</span><span class="o">.</span><span class="n">delay</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">i</span> <span class="c1"># incoming (t, gid) generates output (t + 1 + 0.1*gid, 0)</span>

<span class="c1"># Record all spikes (cell is the only one generating output spikes)</span>
<span class="n">spike_ts</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">Vector</span><span class="p">()</span>
<span class="n">spike_ids</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">Vector</span><span class="p">()</span>
<span class="n">pc</span><span class="o">.</span><span class="n">spike_record</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">spike_ts</span><span class="p">,</span> <span class="n">spike_ids</span><span class="p">)</span>

<span class="c1">#PatternStim</span>
<span class="n">tvec</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="n">gidvec</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="c1"># only 0,1,2 go to cell</span>
<span class="n">ps</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">PatternStim</span><span class="p">()</span>
<span class="n">ps</span><span class="o">.</span><span class="n">play</span><span class="p">(</span><span class="n">tvec</span><span class="p">,</span> <span class="n">gidvec</span><span class="p">)</span>
<span class="k">del</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">gidvec</span> <span class="c1"># ps retains a copy of the (t, gid) info.</span>

<span class="c1">#Run</span>
<span class="n">pc</span><span class="o">.</span><span class="n">set_maxstep</span><span class="p">(</span><span class="mf">10.</span><span class="p">)</span>
<span class="n">h</span><span class="o">.</span><span class="n">finitialize</span><span class="p">(</span><span class="o">-</span><span class="mi">65</span><span class="p">)</span>
<span class="n">pc</span><span class="o">.</span><span class="n">psolve</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>

<span class="k">for</span> <span class="n">spike_t</span><span class="p">,</span> <span class="n">spike_cell_id</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">spike_ts</span><span class="p">,</span> <span class="n">spike_ids</span><span class="p">):</span>
  <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">spike_t</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">spike_cell_id</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt>Output:</dt><dd><p>Notice that 2.1 is the first output because (0, 0) is discarded by PatternStim
because fake_fire=0 and gid=0 is owned by this process.
(1, 1) is the first spike that gets passed into a NetCon (with delay 1.1) so the
first output spike is generated at 2.2 and that spike gets recursively regenerated every
1.0 ms. PatternStim spikes with gid &gt; 3 are discarded.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">2.1</span> <span class="mi">0</span>
<span class="mf">3.1</span> <span class="mi">0</span>
<span class="mf">3.2</span> <span class="mi">0</span>
<span class="mf">4.1</span> <span class="mi">0</span>
<span class="mf">4.2</span> <span class="mi">0</span>
<span class="mf">4.3</span> <span class="mi">0</span>
<span class="mf">5.1</span> <span class="mi">0</span>
<span class="mf">5.2</span> <span class="mi">0</span>
<span class="mf">5.3</span> <span class="mi">0</span>
<span class="mf">6.1</span> <span class="mi">0</span>
<span class="mf">6.2</span> <span class="mi">0</span>
<span class="mf">6.3</span> <span class="mi">0</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="py class">
<dt class="sig sig-object py" id="IntFire1">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">IntFire1</span></span><a class="headerlink" href="#IntFire1" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">h.IntFire1()</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.tau</span> <span class="pre">---</span> <span class="pre">ms</span> <span class="pre">time</span> <span class="pre">constant</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.refrac</span> <span class="pre">---</span> <span class="pre">ms</span> <span class="pre">refractory</span> <span class="pre">period.</span> <span class="pre">Minimum</span> <span class="pre">time</span> <span class="pre">between</span> <span class="pre">events</span> <span class="pre">is</span> <span class="pre">refrac</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.m</span> <span class="pre">---</span> <span class="pre">state</span> <span class="pre">variable</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.M</span> <span class="pre">---</span> <span class="pre">analytic</span> <span class="pre">value</span> <span class="pre">of</span> <span class="pre">state</span> <span class="pre">at</span> <span class="pre">current</span> <span class="pre">time,</span> <span class="pre">t</span></code></p>
</dd>
<dt>Description:</dt><dd><p>A point process that is equivalent to an entire integrate and fire cell.</p>
<p>An output
spike event is sent to all the NetCon instances which have this pointprocess
instance as their source when m &gt;= 1
If m(t0) = m0 and an input event occurs at t1
then the value of m an infinitesimal time before the t1 event is
exp(-(t1 - t0)/tau). After the input event m(t1) = m(t1) + weight where weight
is the weight of the NetCon event.
Input events are ignored for refrac time after the spike output
event.</p>
<p>During the refractory period,  m = 2.
At the end of the refractory period, m = 0.
During the refractory period, the function M() returns a value of 2
for the first 0.5 ms and -1 for the rest of the period. Otherwise it
returns exp((t-t0)/tau)</p>
<p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/intfire1.mod">&lt;nrn src dir&gt;/src/nrnoc/intfire1.mod</a></p>
</dd>
</dl>
<p>Example:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">neuron</span> <span class="kn">import</span> <span class="n">h</span>
<span class="kn">from</span> <span class="nn">neuron.units</span> <span class="kn">import</span> <span class="n">ms</span><span class="p">,</span> <span class="n">mV</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">h</span><span class="o">.</span><span class="n">load_file</span><span class="p">(</span><span class="s2">&quot;stdrun.hoc&quot;</span><span class="p">)</span>

<span class="n">my_cell</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">IntFire1</span><span class="p">()</span>
<span class="n">my_cell</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">ms</span>
<span class="n">my_cell</span><span class="o">.</span><span class="n">refrac</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">ms</span>

<span class="c1"># stimuli</span>
<span class="n">e_stims</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">NetStim</span><span class="p">()</span>
<span class="n">e_stims</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">e_stims</span><span class="o">.</span><span class="n">interval</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">ms</span>
<span class="n">e_stims</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">ms</span>
<span class="n">e_stims</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="mf">1e10</span>
<span class="n">nc</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">NetCon</span><span class="p">(</span><span class="n">e_stims</span><span class="p">,</span> <span class="n">my_cell</span><span class="p">)</span>
<span class="n">nc</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">nc</span><span class="o">.</span><span class="n">delay</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">ms</span>

<span class="c1"># setup recording</span>
<span class="n">stim_times</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">Vector</span><span class="p">()</span>
<span class="n">output_times</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">Vector</span><span class="p">()</span>
<span class="n">stim_times_nc</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">NetCon</span><span class="p">(</span><span class="n">e_stims</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="n">stim_times_nc</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">stim_times</span><span class="p">)</span>
<span class="n">output_times_nc</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">NetCon</span><span class="p">(</span><span class="n">my_cell</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="n">output_times_nc</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">output_times</span><span class="p">)</span>

<span class="c1"># run the simulation</span>
<span class="n">h</span><span class="o">.</span><span class="n">finitialize</span><span class="p">(</span><span class="o">-</span><span class="mi">65</span> <span class="o">*</span> <span class="n">mV</span><span class="p">)</span>
<span class="n">h</span><span class="o">.</span><span class="n">continuerun</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">ms</span><span class="p">)</span>


<span class="c1"># show a raster plot of the output spikes and the stimulus times</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

<span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([(</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="n">stim_times</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">output_times</span><span class="p">)]):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">c</span> <span class="o">-</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">color</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">([</span><span class="s1">&#39;excitatory</span><span class="se">\n</span><span class="s1">stimuli&#39;</span><span class="p">,</span><span class="s1">&#39;output</span><span class="se">\n</span><span class="s1">events&#39;</span><span class="p">])</span>

<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">t</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;time (ms)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference external" href="https://colab.research.google.com/drive/1c02kKjinPAfwdabxMv79fErlqugFVOPo?usp=sharing">Click here</a>
for a runnable version of this example.
(To interactively run it, either make a copy or choose
File - Open in playground mode.)</p>
</div></blockquote>
</dd></dl>

<hr class="docutils" />
<dl class="py class">
<dt class="sig sig-object py" id="IntFire2">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">IntFire2</span></span><a class="headerlink" href="#IntFire2" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">h.IntFire2()</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.taum</span> <span class="pre">---</span> <span class="pre">ms</span> <span class="pre">membrane</span> <span class="pre">time</span> <span class="pre">constant</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.taus</span> <span class="pre">--</span> <span class="pre">ms</span> <span class="pre">synaptic</span> <span class="pre">current</span> <span class="pre">time</span> <span class="pre">constant</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.ib</span> <span class="pre">--</span> <span class="pre">constant</span> <span class="pre">current</span> <span class="pre">input</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.m</span> <span class="pre">---</span> <span class="pre">membrane</span> <span class="pre">state</span> <span class="pre">variable</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.M</span> <span class="pre">---</span> <span class="pre">analytic</span> <span class="pre">value</span> <span class="pre">of</span> <span class="pre">state</span> <span class="pre">at</span> <span class="pre">current</span> <span class="pre">time,</span> <span class="pre">t</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.i</span> <span class="pre">---</span> <span class="pre">synaptic</span> <span class="pre">current</span> <span class="pre">state</span> <span class="pre">variable</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.I</span> <span class="pre">---</span> <span class="pre">analytic</span> <span class="pre">value</span> <span class="pre">of</span> <span class="pre">synaptic</span> <span class="pre">current.</span></code></p>
</dd>
<dt>Description:</dt><dd><p>A leaky integrator with time constant taum driven by a total
current that is the sum of
{ a user-settable constant “bias” current }
plus
{ a net synaptic current }.
Net synaptic current decays toward 0 with time constant taus, where
taus &gt; taum (synaptic
current decays slowly compared to the rate at which “membrane potential”
m equilibrates).
When an input event with weight w arrives, the net synaptic current
changes abruptly by
the amount w.</p>
<p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/intfire2.mod">&lt;nrn src dir&gt;/src/nrnoc/intfire2.mod</a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="py class">
<dt class="sig sig-object py" id="IntFire4">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">IntFire4</span></span><a class="headerlink" href="#IntFire4" title="Link to this definition"></a></dt>
<dd><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">h.IntFire4()</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.taue</span> <span class="pre">---</span> <span class="pre">ms</span> <span class="pre">excitatory</span> <span class="pre">input</span> <span class="pre">time</span> <span class="pre">constant</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.taui1</span> <span class="pre">---</span> <span class="pre">ms</span> <span class="pre">inhibitory</span> <span class="pre">input</span> <span class="pre">rise</span> <span class="pre">time</span> <span class="pre">constant</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.taui2</span> <span class="pre">---</span> <span class="pre">ms</span> <span class="pre">inhibitory</span> <span class="pre">input</span> <span class="pre">fall</span> <span class="pre">time</span> <span class="pre">constant</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.taum</span> <span class="pre">---</span> <span class="pre">membrane</span> <span class="pre">time</span> <span class="pre">constant</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.m</span> <span class="pre">---</span> <span class="pre">membrane</span> <span class="pre">state</span> <span class="pre">variable</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.M</span> <span class="pre">---</span> <span class="pre">analytic</span> <span class="pre">value</span> <span class="pre">of</span> <span class="pre">membrane</span> <span class="pre">state</span> <span class="pre">at</span> <span class="pre">current</span> <span class="pre">time,</span> <span class="pre">t</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.e</span> <span class="pre">---</span> <span class="pre">excitatory</span> <span class="pre">current</span> <span class="pre">state</span> <span class="pre">variable</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.E</span> <span class="pre">---</span> <span class="pre">analytic</span> <span class="pre">value</span> <span class="pre">of</span> <span class="pre">excitation</span> <span class="pre">current</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.i1</span> <span class="pre">c.i2</span> <span class="pre">--</span> <span class="pre">inhibitory</span> <span class="pre">current</span> <span class="pre">state</span> <span class="pre">variables</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">c.I</span> <span class="pre">---</span> <span class="pre">analytic</span> <span class="pre">value</span> <span class="pre">of</span> <span class="pre">inhibitory</span> <span class="pre">current.</span></code></p>
</dd>
<dt>Description:</dt><dd><p>The IntFire4 artificial cell treats excitatory input (positive weight)
events as a sudden change in
current which decays exponentially with time constant taue. Inhibitory
input (negative weight)
events are treated as an alpha function like change to the current. More
precisely the current due
to a negative weight event is the difference between two exponentials
with time constants taui1
and taui2. In the limit as taui2 approaches taui1 then the current due
to the event approaches the
alpha function. The current due to the input events is integrated with a
membrane time constant
of taum. At present there is a constraint taue &lt; taui1 &lt; taui2 &lt; taum
but this may become
relaxed to taue, taui1 &lt; taui2, taum. When the membrane potential
reaches 1, the cell fires and
the membrane potential is re-initialized to 0 and starts integrating
according to the analytic
value of the current (which does NOT depend on firing). Excitatory
events are scaled such that
an isolated event of weight 1 will produce a maximum membrane potential
of 1 (threshold) and
an isolated inhibitory event of weight -1 will produce a minimum
membrane potential of -1.</p>
<p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/intfire4.mod">&lt;nrn src dir&gt;/src/nrnoc/intfire4.mod</a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
</section>
</section>
<section id="mechanisms">
<span id="mech-mechanisms"></span><h1>Mechanisms<a class="headerlink" href="#mechanisms" title="Link to this heading"></a></h1>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><span class="xref std std-ref">insert</span>, <a class="reference internal" href="../../../simctrl/stdrun.html#inserter"><span class="std std-ref">Inserter</span></a>, <a class="reference internal" href="../../../../hoc/modelspec/programmatic/mechanisms/nmodl.html#nmodl"><span class="std std-ref">NMODL</span></a></p>
</div>
<hr class="docutils" />
<p id="mech-setdata"><span id="index-0"></span><strong>setdata</strong></p>
<blockquote>
<div><dl class="simple">
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">h.setdata_suffix(section(x))</span></code></p>
</dd>
<dt>Deprecated for Python:</dt><dd><p>In Python one can use the syntax <code class="docutils literal notranslate"><span class="pre">section(x).suffix.fname(args)</span></code> to call a FUNCTION
or PROCEDURE regardless of whether the function uses RANGE variables.</p>
</dd>
<dt>Description:</dt><dd><p>If a mechanism function is called that uses RANGE variables, then the
appropriate data needed by the function must first be indicated via a setdata call.
This is unnecessary if the function uses only GLOBAL variables.
The suffix refers to the name of the mechanism. E.g. <code class="docutils literal notranslate"><span class="pre">h.setdata_hh(soma(0.5)).</span></code></p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The THREADSAFE mechanism case is a bit more complicated if the mechanism
anywhere assigns a value to a GLOBAL variable. When the user explicitly
specifies that a mechanism is THREADSAFE, those GLOBAL variables that
anywhere appear on the left hand side of an assignment statement (and there
is no such assignment with the PROTECT prefix)
are actually
thread specific variables.
Hoc access to thread specific global variables is with respect to a static
instance which is shared by
the first thread in which mechanism actually exists.</p>
</div>
</div></blockquote>
<hr class="docutils" />
<p id="mech-capacitance"><span id="index-1"></span><strong>capacitance</strong></p>
<blockquote>
<div><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">section.cm</span> <span class="pre">(uF/cm2)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">section.i_cap</span> <span class="pre">(mA/cm2)</span></code></p>
</dd>
<dt>Description:</dt><dd><p>capacitance is a mechanism that automatically is inserted into every section.
cm is a range variable with a default value of 1.0.
i_cap is a range variable which contains the varying membrane capacitive current
during a simulation. Note that i_cap is most accurate when a variable step
integration method is used.</p>
</dd>
</dl>
</div></blockquote>
<hr class="docutils" />
<p id="mech-hh"><span id="index-2"></span><strong>hh</strong></p>
<blockquote>
<div><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">section.insert('hh')</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">section.insert(h.hh)</span></code></p>
</dd>
<dt>Description:</dt><dd><p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/hh.mod">&lt;nrn src dir&gt;/src/nrnoc/hh.mod</a></p>
<p>Hodgkin-Huxley sodium, potassium, and leakage channels. Range variables
specific to this model are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>hh.gnabarh  0.120 mho/cm2   Maximum specific sodium channel conductance
hh.gkbar    0.036 mho/cm2   Maximum potassium channel conductance
hh.gl       0.0003 mho/cm2  Leakage conductance
hh.el       -54.3 mV        Leakage reversal potential
hh.m                        sodium activation state variable
hh.h                        sodium inactivation state variable
hh.n                        potassium activation state variable
hh.ina      mA/cm2          sodium current through the hh channels
hh.ik       mA/cm2          potassium current through the hh channels

h.rates_hh(v) computes the global variables [mhn]inf_hh and [mhn]tau_hh
from the rate functions. usetable_hh defaults to 1.
</pre></div>
</div>
<p>This model used the na and k ions to read ena, ek and write ina, ik.</p>
</dd>
</dl>
</div></blockquote>
<hr class="docutils" />
<p id="mech-pas"><span id="index-3"></span><strong>pas</strong></p>
<blockquote>
<div><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">section.insert('pas')</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">section.insert(h.pas)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">section(x).pas.g</span> <span class="pre">--</span> <span class="pre">mho/cm2</span>&#160;&#160; <span class="pre">conductance</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">section(x).pas.e</span> <span class="pre">--</span> <span class="pre">mV</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">reversal</span> <span class="pre">potential</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">section(x).pas.i</span> <span class="pre">--</span> <span class="pre">mA/cm2</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">non-specific</span> <span class="pre">current</span></code></p>
</dd>
<dt>Description:</dt><dd><p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/passive.mod">&lt;nrn src dir&gt;/src/nrnoc/passive.mod</a></p>
<p>Passive membrane channel.</p>
</dd>
</dl>
</div></blockquote>
<hr class="docutils" />
<p id="mech-fastpas"><span id="index-4"></span><strong>fastpas</strong></p>
<blockquote>
<div><p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/passive0.c">&lt;nrn src dir&gt;/src/nrnoc/passive0.c</a></p>
<p>Passive membrane channel. Same as the <a class="reference internal" href="#mech-pas"><span class="std std-ref">pas</span></a> mechanism but hand coded to
be a bit faster (avoids the wasteful numerical derivative computation of
the conductance and does not save the current). Generally not worth
using since passive channel computations are not usually the rate limiting
step of a simulation.</p>
</div></blockquote>
<hr class="docutils" />
<p id="mech-extracellular"><span id="index-5"></span><strong>extracellular</strong></p>
<blockquote>
<div><dl>
<dt>Syntax:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">section.insert('extracellular')</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">nlayer</span> <span class="pre">=</span> <span class="pre">h.nlayer_extracellular()</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">nlayer</span> <span class="pre">=</span> <span class="pre">h.nlayer_extracellular(nlayer)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">.vext[nlayer]</span> <span class="pre">--</span> <span class="pre">mV</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">.i_membrane</span> <span class="pre">--</span> <span class="pre">mA/cm2</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">.xraxial[nlayer]</span> <span class="pre">--</span> <span class="pre">MOhms/cm</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">.xg[nlayer]</span>&#160;&#160; <span class="pre">--</span> <span class="pre">mho/cm2</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">.xc[nlayer]</span>&#160;&#160; <span class="pre">--</span> <span class="pre">uF/cm2</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">.extracellular.e</span> <span class="pre">--</span> <span class="pre">mV</span></code></p>
</dd>
<dt>Description:</dt><dd><p>By default, adds two layers of extracellular field to the section. Vext is
solved simultaneously with the v. When the extracellular mechanism
is present, v refers to the membrane potential and vext (i.e. vext[0])
refers to
the extracellular potential just next to the membrane. Thus the
internal potential is v+vext (but see Warning below).</p>
<p>This mechanism is useful for simulating the stimulation with
extracellular electrodes, response in the presence of an extracellular
potential boundary condition computed by some external program, leaky
patch clamps, incomplete seals in the myelin sheath along with current
flow in the space between the myelin and the axon. It is required
when connecting <a class="reference internal" href="../linmod.html#LinearMechanism" title="LinearMechanism"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearMechanism</span></code></a> (e.g. a circuit built with
the <span class="menuselection">NEURON Main Menu ‣ Build ‣ Linear Circuit</span>) to extracellular nodes.</p>
<p>i_membrane correctly does not include contributions from ELECTRODE_CURRENT
point processes.</p>
<p>See i_membrane_ at <a class="reference internal" href="../../../simctrl/cvode.html#CVode.use_fast_imem" title="CVode.use_fast_imem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CVode.use_fast_imem()</span></code></a>. i_membrane_
has units of nA instead of mA/cm2 (i.e. total membrane current
out of the segment) and so is available at 0 and 1 locations of
sections. It does not require that extracellular be inserted and so
results in much faster simulations. It works during parallel simulations
with variable step methods.</p>
<p>The figure illustrates the form the electrical equivalent circuit
when this mechanism is present. Note that previous documentation
was incorrect in showing that extracellular.e was in series with
the <code class="docutils literal notranslate"><span class="pre">xg[nlayer-1],xc[nlayer-1]</span></code> parallel combination.
In fact it has always been the case
that extracellular.e was in series with <code class="docutils literal notranslate"><span class="pre">xg[nlayer-1]</span></code> and <code class="docutils literal notranslate"><span class="pre">xc[nlayer-1]</span></code>
was in parallel with that series combination.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The only reason for default nlayer=2 is so that when only a single
layer is needed (the usual case), then extracellular.e is consistent
with the previous documentation with the old default nlayer=1.
If you are not using both xc[0] &gt; 0 and extracellular.e != 0 then
nlayer=1 is sufficient and faster than nlayer=2.</p>
</div>
<p>The number of extracellular layers can be changed with the
h.nlayer_extracellular(nlayer) function. (Returns the current
number extracellular layers with or without the argument). The number
of layers can be changed only if there are no existing
extracellular mechanism instances in any section. Array limits
for xraxial, xc, xg, and vext are <code class="docutils literal notranslate"><span class="pre">[0:nlayer]</span></code>. The minimum
value for nlayer is 1. Default values are xg[i] = 1e9, xc[i] = 0.0
xraxial[i] = 1e9, so all layers start out tightly connected to ground.</p>
<p>With two layers the equivalent circuit looks like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>          Ra
o/`--o--&#39;\/\/`--o--&#39;\/\/`--o--&#39;\/\/`--o--&#39;\o vext + v
     |          |          |          |
    ---        ---        ---        ---
   |   |      |   |      |   |      |   |
    ---        ---        ---        ---
     |          |          |          |
     |          |          |          |     i_membrane
     |  xraxial |          |          |
 /`--o--&#39;\/\/`--o--&#39;\/\/`--o--&#39;\/\/`--o--&#39;vext
     |          |          |          |
    ---        ---        ---        ---     xc and xg
   |   |      |   |      |   |      |   |    in  parallel
    ---        ---        ---        ---
     |          |          |          |
     |          |          |          |
     |xraxial[1]|          |          |
 /`--o--&#39;\/\/`--o--&#39;\/\/`--o--&#39;\/\/`--o--&#39;vext[1]
     |          |          |          |
    ---        ---        ---        ---     the series xg[1], e_extracellular
   |   |      |   |      |   |      |   |    combination is in parallel with
   |  ---     |  ---     |  ---     |  ---   the xc[1] capacitance. This is
   |   -      |   -      |   -      |   -    identical to a membrane with
    ---        ---        ---        ---     cm, g_pas, e_pas
     |          |          |          |
-------------------------------------------- ground
</pre></div>
</div>
<p>Extracellular potentials do a great deal
of violence to one’s intuition and it is important that the user
carefully consider the results of simulations that use them.
It is best to start out believing that there are bugs in the method
and attempt to prove their existence.</p>
<p>See <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/src/nrnoc/extcell.c">&lt;nrn src dir&gt;/src/nrnoc/extcelln.c</a>
and <a class="reference external" href="https://github.com/neuronsimulator/nrn/blob/master/share/examples/nrniv/nrnoc">&lt;nrn src dir&gt;/examples/nrnoc/extcab*.hoc</a>.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>xcaxial is also defined but is not implemented. If you need those
then add them with the <a class="reference internal" href="../linmod.html#LinearMechanism" title="LinearMechanism"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearMechanism</span></code></a> .</p>
<p>Prior versions of this document indicated that
e_extracellular is in series with the parallel (xc,xg)
pair. In fact it was in series with xg of the layer.
The above equivalent circuit has been changed to reflect the truth
about the implementation.</p>
<p>In v4.3.1 2000/09/06 and before
vext(0) and vext(1) are the voltages at the centers of the first and
last segments instead of the zero area nodes.</p>
<p>Now the above bug is fixed and
vext(0) and vext(1) are the voltages at the zero area nodes.</p>
<p>From extcelln.c the comment is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        i_membrane = sav_g * ndlist[i]-&gt;v + sav_rhs;
#if 1
        /* i_membrane is a current density (mA/cm2). However
           it contains contributions from Non-ELECTRODE_CURRENT
           point processes. i_membrane(0) and i_membrane(1) will
           return the membrane current density at the points
           0.5/nseg and 1-0.5/nseg respectively. This can cause
           confusion if non-ELECTRODE_CURRENT point processes
           are located at these 0-area nodes since 1) not only
           is the true current density infinite, but 2) the
           correct absolute current is being computed here
             at the x=1 point but is not available, and 3) the
           correct absolute current at x=0 is not computed
           if the parent is a rootnode or there is no
           extracellular mechanism for the parent of this
           section. Thus, if non-ELECTRODE_CURRENT point processes
           eg synapses, are being used it is not a good idea to
           insert them at the points x=0 or x=1
        */
#else
           i_membrane *= ndlist[i]-&gt;area;
           /* i_membrane is nA for every segment. This is different
              from all other continuous mechanism currents and
              same as PointProcess currents since it contains
              non-ELECTRODE_CURRENT point processes and may
              be non-zero for the zero area nodes.
           */
#endif
</pre></div>
</div>
<p>In v4.3.1 2000/09/06 and before
extracellular layers will not be connected across sections unless
the parent section of the connection contains the extracellular
mechanism. This is because the 0 area node of the connection is
“owned” by the parent section. In particular, root nodes never contain
extracellular mechanisms and thus multiple sections connected to the
root node always appear to be extracellularly disconnected.
This bug has been fixed. However it is still the case that
vext(0) can be non-zero only if the section owning the 0 node has had
the extracellular mechanism inserted. It is best to have every section
in a cell contain the extracellular mechanism if any one of them does
to avoid confusion with regard to (the in fact correct) boundary conditions.</p>
</div>
</div></blockquote>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../linmod.html" class="btn btn-neutral float-left" title="LinearMechanism" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="nmodl.html" class="btn btn-neutral float-right" title="NMODL" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Duke, Yale and the Blue Brain Project.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>